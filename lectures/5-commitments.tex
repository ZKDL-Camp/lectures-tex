\documentclass[../lecture-notes.tex]{subfiles}

\begin{document}

\subsection{Commitments}

\begin{definition}
    A cryptographic commitment scheme allows one party to commit to a chosen statement (such as a value, vector, or polynomial) without revealing the statement itself. The commitment can be revealed in full or in part at a later time, ensuring the integrity and secrecy of the original statement until the moment of disclosure.
\end{definition}

Before delving into the details, here is the intuition of cryptographic commitments.

Imagine putting a cat into a box and locking it with your key. 
You then give that box to your friend, who cannot open it without the key.
In this scenario, you have made a commitment to the cat inside the box. 
You cannot change the content of the box, as it is in your friend's possession. 
At the same time, your friend cannot access the letter since they do not have the key to unlock the box.

\begin{center}
    \centering\includegraphics[width=0.5\linewidth, clip]{images/lecture_5/CommitmentExample.png}

    \scriptsize{\textbf{Illustration:} Commitment scheme}
\end{center}

\begin{definition}[Commitment Scheme]
    
    Commitment Scheme $\Pi_{\text{commitment}}$ is a tuple of three algorithms: $\Pi_{\text{commitment}} = (\mathsf{Setup}, \mathsf{Commit}, \mathsf{Verify})$.
     
    \begin{enumerate}

        \item \textit{Setup:}  prover and verifier agree on common parameters before the commitment process begins;

        \item \textit{Commit:} prover selects a value and generates a commitment to this value. This commitment is then sent to the verifier;

        \item  \textit{Verify:} prover reveals the committed value and any necessary information to the verifier. 
    \end{enumerate}
\end{definition}

\begin{definition}[Commitment Scheme]
    Properties of a commitment scheme:
    \begin{enumerate}
        \item \textit{Hiding: } verifier should not learn any information about the message given only the commitment c. To put it formally we define a game:
        \begin{enumerate}
            \item Adversary chooses two messages $m_1,m_2$ and sends to the challenger.
            \item Challenger chooses a random bit $b$, commits to both messages: 
            
                $c_1 \gets \mathsf{Commit}(pp, m_1), c_2 \gets \mathsf{Commit}(pp,m_2)$, and sends $c_b$ to the adversary.
            \item Adversary guesses a bit $\hat{b}$.
        \end{enumerate}
        
        The advantage of hiding of a PPT adversary $\mathcal{A}$ as 
        
        $$
        \mathsf{HideAdv}[\mathcal{A}, \Pi_{\text{commitment}}] := \left| \text{Pr}[b=\hat{b}] - \frac{1}{2} \right|
        $$
        
        We say that the commitment scheme $\Pi_{\text{commitment}}$ is \textit{hiding} if for any adversary, the aforementioned advantage is negligible.
        
        \item \textit{Binding: } prover could not find another message $m_1$ and open the commitment $c$ without revealing the commited message $m$.
    \end{enumerate}
\end{definition}

\subsubsection{Hash-based commitments}

As the name implies, we are using a cryptographic hash function \(H\) in such scheme.

\begin{enumerate}
    \item Prover selects a message $m$ which he wants to commit:
        $m \leftarrow \mathbb{Z}$

    \item Prover samples random value $r$ (usually called blinding factor) from $\mathbb{Z}$:
        $r \xleftarrow{R} \mathbb{Z}$
    
    \item Both values will be concatenated and hashed with the hash function $H$ to produce the commitment:
        $c = H(m || r)$

\end{enumerate}

Commitment should be shared with a verifier. During the verification stage, prover reveals $(m, r)$ to the verifier. 
To check the commitment, verifier computes: $c_1 = H(m || r)$.

If $c_1 = c$, prover has revealed the correct pair $(m, r)$.

\subsubsection{Pedersen commitments}

Pedersen commitments allow us to represent arbitrarily large vectors with a single elliptic curve point, while optionally hiding any information about the vector. Pedersen commitment uses a public group $\mathbb{G}$ of order $q$ and two random public generators $G$ and $U$: $U = uG$. Secret parameter $u$ should be hidden, otherwise the $\textit{Binding}$ property of the commitment scheme will be violated.
EC point $U$ is chosen randomly using "Nothing-up-my-sleeve" to assure no one knows the discrete logarithm of a selected point.

\begin{remark}
    \textbf{Transparent random points generation}

    User can pick the publicly chosen random number (like a hash of project name, first numbers of $\pi$, etc), and hash that result to obtain another value. If that results in an $x$ value that lies on the elliptic curve, use that as the random point and hash the $(x, y)$ pair again (to obtain the next one, it needed). Otherwise, if the $x$-value does not land on the curve, increment $x$ until it does. Because the committer is not generating the points, they don`t know their discrete log. 
\end{remark}

Pedersen commitment scheme algorithm:
\begin{enumerate}
    \item Prover and Verifier agrees on $G$ and $U$ points
    \item Prover selects a value $m$ to commit and a blinder factor $r$:
            $m \leftarrow \mathbb{Z}$,
            $r \xleftarrow{R} \mathbb{Z}$
    \item Prover generates a commitment and sends it to the Verifier:
            $c = mG + rU$
\end{enumerate}

During the verification stage, prover reveals $(m, r)$ to the verifier. 
To check the commitment, verifier computes: $c_1 = mG + rU$.

If $c_1 = c$, prover has revealed the correct pair $(m, r)$.

\begin{remark}
    In case the discrete logarithm of $U$ is leaked, the \textit{binding} property can be violated by the \textit{Prover}:

    $c = mG + rU = m \cdot G + r*u \cdot G = (m + r*u) \cdot G$
    
    For example, $(m + u, r - 1)$ will have the same commitment value:

    $(m+u + (r-1)*u) \cdot G = (m + u - u + r*u) \cdot G = (m + r*u) \cdot G$ 
        
\end{remark}

\textbf{Commitment aggregation}

Pedersen commitment have some advantages compared to hash-based commitments.
Additively homomorphic property allows to accumulate multiple commitments into one.
Consider two pairs: $(m_1, r_1), (m_2, r_2)$.

\begin{center}
    $C_1 = m_1G + r_1U$,

    $C_2 = m_2G + r_2U$,

    $C_a = C_1 + C_2 = (m_1 + m_2)G + (r_1 + r_2)U$
\end{center}

This works for any number of commitments, so we can encode as many points as we like in a single one.

\vspace{0.5 cm}

\subsubsection{Vector commitments}

Vector commitment schemes allows to commit to a vector of values rather than a value and a blinding term.

\vspace{0.5 cm}

\textbf{Pedersen Vector Commitments}

Suppose we have a set of random elliptic curve points $(G_1,...,G_n)$ of group $\mathbb{G}$ 
(that we do not know the discrete logarithm of), a vector $[m_1, m_2 ... m_n]$ and a random value $r$. We can do the following:

\begin{center}
    $ [C] = m_1\cdot[G_1] + m_2 \cdot [G_2] ... + m_n \cdot [G_n] + r \cdot [Q]$ 
\end{center}

Since the \textit{Prover} does not know the discrete logarithm of the generators, they don`t know the discrete logarithm of [C]. Hence, this scheme is binding: they can only reveal $(v_1,...,v_n)$ to produce $[C]$ later, they cannot produce another vector.

Prover can later open the commitment by revealing the vector $[m_1, m_2 ... m_n]$ and a blinding term $r$.

\vspace{0.5 cm}

\textbf{Merkle Tree based Vector Commitments}

A naive approach for a vector commitment would be hash the whole vector. More sophisticated scheme uses divide-and-conquer approach by building a binary tree out of vector elements.

\begin{center}
    \centering\includegraphics[width=0.9\linewidth, clip]{images/lecture_5/MerkleTree.png}

    \scriptsize{\textbf{Illustration:} Merkle Tree structure}
\end{center}

A Merkle Tree is a data structure to efficiently and securely verify the commiments to a vector of data. It is a binary tree where each leaf node represents a hash of a data block, and each non-leaf node is a hash of its child nodes' concatenated hashes. The top node, called the root hash or Merkle root, uniquely represents the entire data set. By comparing this root with a known valid root, one can quickly verify the authenticity and integrity of the data without needing to examine the entire dataset. 

To prove the inclusion of element into the tree, a corresponding Merkle Branch is used. On the example below, $M_1$ inclusion is proved, and 
$[M_2, H(M_3 || M_4), H(H(M_5 || M_6) || H(M_7 || M_8))]$ is an inclusion branch vector.

\begin{center}
    \centering\includegraphics[width=0.9\linewidth, clip]{images/lecture_5/MerkleTreeProof.png}

    \scriptsize{\textbf{Illustration:} Merkle Tree structure}
\end{center}

One of Merkle tree key advantages is that it allows for the selective disclosure of specific elements within the data set without revealing the rest. 

\subsubsection{Polynomial commitment}

Polynomial commitment can be used to prove that the commited polynomial satisfies certain properties (passes through a certain point $(x,y)$), without revealing what the polynomial is.
The commitment is generally succint, which means that it is much smaller than the polynomial it represents.

\vspace{0.5 cm}

\textbf{The KZG polynomial commitment scheme}

\vspace{0.5 cm}


The KZG (Kate-Zaverucha-Goldberg) is a polynomial commitment scheme:

\textit{Setup stage}

\begin{enumerate}
    \item One-time trusted setup. During trusted setup a set of elliptic curve points is generated. Let $G$ be a generator point of some pairing-friendly
    elliptic curve group $\mathbb{G}$, $s$ some random value in the order of the $G$ point and $d$ be the maximum degree of the polynomials we want to commit to.

    \begin{center}
        $s^0[G], s^1[G], ... s^d[G]$
    \end{center}

    Parameter $s$ should be deleted after the ceremony. If it is revealed, the commitment scheme can be broken. This parameter is usually called the \textit{toxic waste}.

\end{enumerate}

\end{document}