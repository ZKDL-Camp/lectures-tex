\documentclass[../lecture-notes.tex]{subfiles}

\begin{document}

\subsection{Basics of Security Analysis}

In many cases, technical papers include the analysis on the key question: ``How secure is this cryptographic algorithm?'' or rather ``Why this cryptographic algorithm is secure?''. In this section, we will shortly describe the notation and typical construction for justifying the security of cryptographic algorithms.

Typically, the cryptographic security is defined in a form of a game between the adversary (who we call $\mathcal{A}$) and the challenger (who we call $\mathcal{C}h$). The adversary is trying to break the security of the cryptographic algorithm using arbitrary (but still efficient) protocol, while the challenger is following a simple, fixed protocol. The game is played in a form of a challenge, where the adversary is given some information and is asked to perform some task. The security of the cryptographic algorithm is defined based on the probability of the adversary to win the game.

\subsubsection{Cipher Semantic Security}
Let us get into specifics. Suppose that we want to specify that the encryption scheme is secure. Recall that cipher $\mathcal{E} = (E,D)$ over the space $(\mathcal{K}, \mathcal{M}, \mathcal{C})$ (here, $\mathcal{K}$ is the space containing all possible keys, $\mathcal{M}$ -- all possible messages and $\mathcal{C}$ -- all possible ciphers) consists of two efficiently computable methods:
\begin{itemize}
    \item $E: \mathcal{K} \times \mathcal{M} \to \mathcal{C}$ -- encryption method, that based on the provided message $m \in \mathcal{M}$ and key $k \in \mathcal{K}$ outputs the cipher $c = E(k,m) \in \mathcal{C}$.
    \item $D: \mathcal{K} \times \mathcal{C} \to \mathcal{M}$ -- decryption method, that based on the provided cipher $c \in \mathcal{C}$ and key $k \in \mathcal{K}$ outputs the message $m = D(k,c) \in \mathcal{M}$.
\end{itemize}

Of course, we require the \textbf{correctness}:
\begin{equation}
    (\forall k \in \mathcal{K}) \, (\forall m \in \mathcal{M}): \{D(k,E(k,m)) = m\}
\end{equation}

Now let us play the following game between adversary $\mathcal{A}$ and challenger $\mathcal{C}h$:
\begin{enumerate}
    \item $\mathcal{A}$ picks any two messages $m_0,m_1 \in \mathcal{M}$ on his choice.
    \item $\mathcal{C}h$ picks a random key $k \xleftarrow{R} \mathcal{K}$ and random bit $b \xleftarrow{R} \{0,1\}$ and sends the cipher $c = E(k,m_b)$ to $\mathcal{A}$.
    \item $\mathcal{A}$ is trying to guess the bit $b$ by using the cipher $c$.
    \item $\mathcal{A}$ outputs the guess $\hat{b}$.
\end{enumerate}

\begin{figure}
    \centering
    \begin{tikzpicture}
        \node[inner sep=0pt, align=center] (challenger) {\includegraphics[width=0.75cm]{lectures/images/lecture_2/challenger.png}\\Challenger $\mathcal{C}h$};
        \node[inner sep=0pt, align=center, right=5cm of challenger] (adversary) {\includegraphics[width=0.75cm]{lectures/images/lecture_2/demon.png}\\Adversary $\mathcal{A}$};

        \draw [dashed,line width=0.3mm] ([yshift=-0.5cm]challenger.south) -- ([yshift=-9cm]challenger.south);
        \draw [dashed,line width=0.3mm] ([yshift=-0.5cm]adversary.south) -- ([yshift=-9cm]adversary.south);

        \draw[-{Stealth[length=3mm]},line width=0.4mm] ([yshift=-1.5cm]adversary.south) coordinate (l2)--(l2-|challenger) node[midway, above=2mm, fill=white]{Send $m_0, m_1 \in \mathcal{M}, |m_0| = |m_1|$};

        \node[align=center,fill=white!5,thick,below=2.5cm of challenger](challenger-actions){
        \noindent\rule{3.5cm}{0.8pt}\\
        $b \xleftarrow{R} \{0,1\}$ \\
        $k \xleftarrow{R} \mathcal{K}$ \\
        $c \gets E(k,m_b)$ \\
        \noindent\rule{3.5cm}{0.8pt}};

        \draw[-{Stealth[length=3mm]},line width=0.4mm] ([yshift=-6cm]challenger.south) coordinate (l2)--(l2-|adversary) node[midway, above=2mm, fill=white]{Send cipher $c$};

        \node[align=center,fill=white!5,thick,below=7cm of adversary](adversary-guess){
        \noindent\rule{3.5cm}{0.8pt}\\
        Guess bit $\hat{b} \in \{0,1\}$\\
        \noindent\rule{3.5cm}{0.8pt}};
    \end{tikzpicture}

    \caption{The game between the adversary $\mathcal{A}$ and the challenger $\mathcal{C}h$ for defining the semantic security.}
\end{figure}

Now, what should happen if our encryption scheme is secure? The adversary should not be able to guess the bit $b$ with a probability significantly higher than $1/2$ (a random guess). Formally, define the 
\textbf{advantage} of the adversary $\mathcal{A}$ as:
\begin{equation}
    \text{SSAdv}[\mathcal{E}, \mathcal{A}] := \left| \Pr[\hat{b} = b] - \frac{1}{2} \right|
\end{equation}

We say that the encryption scheme is \textbf{semantically secure}\footnote{This version of definition is called a \textbf{bit-guessing} version.} if for any efficient adversary $\mathcal{A}$ the advantage $\text{SSAdv}[\mathcal{A}]$ is negligible. In other words, the adversary cannot guess the bit $b$ with a probability significantly higher than $1/2$.

Now, what negligible means? Let us give the formal definition!

\begin{definition}
    A function $f: \mathbb{N} \to \mathbb{R}$ is called \textbf{negligible} if for all $c \in \mathbb{R}_{>0}$ there exists $n_c \in \mathbb{N}$ such that for any $n \geq n_c$ we have $|f(n)| < 1/n^c$.
\end{definition}

The alternative definition, which is problably easier to interpret, is the following.

\begin{theorem}
    A function $f: \mathbb{N} \to \mathbb{R}$ is \textbf{negligible} if and only if for any $c \in \mathbb{R}_{>0}$, we have
    \begin{equation}
        \lim_{n \to \infty} f(n)n^c = 0
    \end{equation}
\end{theorem}

\begin{example}
    The function $f(n) = 2^{-n}$ is negligible since for any $c \in \mathbb{R}_{>0}$ we have
    \begin{equation}
        \lim_{n \to \infty} 2^{-n}n^c = 0
    \end{equation}

    The function $g(n) = \frac{1}{n!}$ is also negligible for similar reasons.
\end{example}

\begin{example}
    The function $h(n) = \frac{1}{n}$ is not negligible since for $c = 1$ we have
    \begin{equation}
        \lim_{n \to \infty} \frac{1}{n} \times n = 1 \neq 0
    \end{equation}
\end{example}

Well, that is weird. For some reason we are considering a function the depends on some natural number $n$, but what is this number?

Typically, when defining the security of the cryptographic algorithm, we are considering the security parameter $\lambda$ (e.g., the length of the key). The function is negligible if the probability of the adversary to break the security of the cryptographic algorithm is decreasing with the increasing of the security parameter $\lambda$. Moreover, we require that the probability of the adversary to break the security of the cryptographic algorithm is decreasing faster than any polynomial function of the security parameter $\lambda$.

So all in all, we can define the semantic security as follows.

\begin{definition}
    The encryption scheme $\mathcal{E}$ with a security paramter $\lambda \in \mathbb{N}$ is \textbf{semantically secure} if for any efficient adversary $\mathcal{A}$ we have:
    \begin{equation}
        \left|\text{Pr}\begin{bmatrix}[c|c]
            & m_0, m_1 \gets \mathcal{A}, \; k \xleftarrow{R} \mathcal{K}, \; b \xleftarrow{R} \{0,1\} \\
            b = \hat{b} & c \gets E(k,m_b) \\
            &\hat{b} \gets \mathcal{A}(c)
        \end{bmatrix} - \frac{1}{2}\right| < \text{negl}(\lambda)
    \end{equation}
\end{definition}

Do not be afraid of such complex notation, it is quite simple. Notation $\text{Pr}[A \mid B]$ means ``the probability of $A$, given that $B$ occurred''. So our inner probability is read as ``the probability that the guessed bit $\hat{b}$ equals $b$ given the setup on the right''. Then, on the right we define the setup: first we generate two messages $m_0,m_1 \in \mathcal{M}$, then we choose a random bit $b$ and a key $k$, cipher the message $m_b$, send it to the adversary and the adversary, based on provided cipher, gives $\hat{b}$ as an output. We then claim that the probability of the adversary to guess the bit $b$ is close to $1/2$.

Let us see some more examples of how to define the security of certain crypographic objects.

\subsubsection{Discrete Logarithm Assumption (DL)}

Now, let us define the fundamental assumption used in cryptography formally: the \textbf{Discrete Logarithm Assumption} (DL).

\begin{definition}
    Assume that $\mathbb{G}$ is a cyclic group of prime order $r$ generated by $g \in \mathbb{G}$. Define the following game:
    \begin{enumerate}
        \item Both challenger $\mathcal{C}h$ and adversary $\mathcal{A}$ take a description $\mathbb{G}$ as an input: order $r$ and generator $g \in \mathbb{G}$.
        \item $\mathcal{C}h$ computes $\alpha \xleftarrow{R} \mathbb{Z}_r, u \gets g^{\alpha}$ and sends $u \in \mathbb{G}$ to $\mathcal{A}$.
        \item The adversary $\mathcal{A}$ outputs $\hat{\alpha} \in \mathbb{Z}_r$.
    \end{enumerate}

    We define $\mathcal{A}$'s \textbf{advantage in solving the discrete logarithm problem in $\mathbb{G}$}, denoted as $\text{DL}\mathsf{adv}[\mathcal{A},\mathbb{G}]$, as the probability that $\hat{\alpha} = \alpha$.
\end{definition}

\begin{definition}
    The \textbf{Discrete Logarithm Assumption} holds in the group $\mathbb{G}$ if for any efficient adversary $\mathcal{A}$ the advantage $\text{DL}\mathsf{adv}[\mathcal{A},\mathbb{G}]$ is negligible.
\end{definition}

Informally, this assumption means that given $u$, it is very hard to find $\alpha$ such that $u = g^{\alpha}$. But now we can write down this formally!

\subsubsection{Computational Diffie-Hellman (CDH)}

Another fundamental problem in cryptography is the \textbf{Computational Diffie-Hellman} (CDH) problem. It states that given $g^{\alpha},g^{\beta}$ it is hard to find $g^{\alpha\beta}$. This property is frequently used in the construction of cryptographic protocols such as the Diffie-Hellman key exchange.

Let us define this problem formally.

\begin{definition}
    Let $\mathbb{G}$ be a cyclic group of prime order $r$ generated by $g \in \mathbb{G}$. Define the following game:
    \begin{enumerate}
        \item Both challenger $\mathcal{C}h$ and adversary $\mathcal{A}$ take a description $\mathbb{G}$ as an input: order $r$ and generator $g \in \mathbb{G}$.
        \item $\mathcal{C}h$ computes $\alpha, \beta \xleftarrow{R} \mathbb{Z}_r, u \gets g^{\alpha}, v \gets g^{\beta}, w \gets g^{\alpha\beta}$ and sends $u,v \in \mathbb{G}$ to $\mathcal{A}$.
        \item The adversary $\mathcal{A}$ outputs $\hat{w} \in \mathbb{G}$.
    \end{enumerate}

    We define $\mathcal{A}$'s \textbf{advantage in solving the computational Diffie-Hellman problem in $\mathbb{G}$}, denoted as $\text{CDH}\mathsf{adv}[\mathcal{A},\mathbb{G}]$, as the probability that $\hat{w} = w$.
\end{definition}

\begin{definition}
    The \textbf{Computational Diffie-Hellman Assumption} holds in the group $\mathbb{G}$ if for any efficient adversary $\mathcal{A}$ the advantage $\text{CDH}\mathsf{adv}[\mathcal{A},\mathbb{G}]$ is negligible.
\end{definition}

\subsubsection{Decisional Diffie-Hellman (DDH)}

Now, we loosen the requirements a bit. The \textbf{Decisional Diffie-Hellman} (DDH) problem states that given $g^{\alpha},g^{\beta},g^{\alpha\beta}$ it is ``hard'' to distinguish $g^{\alpha\beta}$ from a random element in $\mathbb{G}$. Formally, we define this problem as follows.

\begin{definition}
    Let $\mathbb{G}$ be a cyclic group of prime order $r$ generated by $g \in \mathbb{G}$. Define the following game:
    \begin{enumerate}
        \item Both challenger $\mathcal{C}h$ and adversary $\mathcal{A}$ take a description $\mathbb{G}$ as an input: order $r$ and generator $g \in \mathbb{G}$.
        \item $\mathcal{C}h$ computes $\alpha, \beta,\gamma \xleftarrow{R} \mathbb{Z}_r, u \gets g^{\alpha}, v \gets g^{\beta}, w_0 \gets g^{\alpha\beta}, w_1 \gets g^{\gamma}$. Then, $\mathcal{C}h$ flips a coin $b \xleftarrow{R} \{0,1\}$ and sends $u,v,w_b$ to $\mathcal{A}$.
        \item The adversary $\mathcal{A}$ outputs the predicted bit $\hat{b} \in \{0,1\}$.
    \end{enumerate}

    We define $\mathcal{A}$'s \textbf{advantage in solving the Decisional Diffie-Hellman problem in $\mathbb{G}$}, denoted as $\text{DDH}\mathsf{adv}[\mathcal{A},\mathbb{G}]$, as
    \begin{equation}
        \text{DDH}\mathsf{adv}[\mathcal{A},\mathbb{G}] := \left| \Pr[b = \hat{b}] - \frac{1}{2} \right|
    \end{equation}
\end{definition}

Now, let us break this assumption for some quite generic group! Consider the following example.

\begin{theorem}
    Suppose that $\mathbb{G}$ is a cyclic group of an even order. Then, the Decision
    Diffie-Hellman Assumption does not hold in $\mathbb{G}$. In fact, there is an efficient adversary $\mathcal{A}$ that can distinguish $g^{\alpha\beta}$ from a random element in $\mathbb{G}$ with an advantage $1/4$.
\end{theorem}

\textbf{Proof.} If $|\mathbb{G}|=2n$ for $n \in \mathbb{N}$, it means that we can split the group into two subgroups of order $n$, say, $\mathbb{G}_1$ and $\mathbb{G}_2$. The first subgroup consists of elements in a form $g^{2k}$, while the second subgroup consists of elements in a form $g^{2k+1}$.

Now, if we could efficiently determine, based on group element $g \in \mathbb{G}$, whether $g \in \mathbb{G}_1$ or $g \in \mathbb{G}_2$, we essentially could solve the problem. Fortunately, there is such a method! Consider the following lemma.

\begin{lemma}
    Suppose $u=g^{\alpha}$. Then, $\alpha$ is even if and only if $u^n = 1$.
\end{lemma}

\textbf{Proof.} If $\alpha$ is even, then $\alpha = 2\alpha'$ and thus
\begin{equation}
    u^n = (g^{2\alpha'})^n = g^{2n\alpha'} = (g^{2n})^{\alpha'} = 1^{\alpha'} = 1
\end{equation}

Conversely, if $u^n = 1$ then $u^{\alpha n}=1$, meaning that $2n \mid \alpha n$, implying that $\alpha$ is even. Lemma is proven.

Now, we can construct our adversary $\mathcal{A}$ as follows. Suppose $\mathcal{A}$ is given $(u,v,w)$. Then,
\begin{enumerate}
    \item Based on $u$, get the parity of $\alpha$, say $p_{\alpha} \in \{\text{even}, \text{odd}\}$.
    \item Based on $v$, get the parity of $\beta$, say $p_{\beta} \in \{\text{even}, \text{odd}\}$.
    \item Based on $w$, get the parity of $\gamma$, say $p_{\gamma} \in \{\text{even}, \text{odd}\}$.
    \item Calculate $p_{\gamma}'\in \{\text{even}, \text{odd}\}$ --- parity of $\alpha\beta$.
    \item Return $\hat{b}=0$ if $p_{\gamma}' = p_{\gamma}$, and $\hat{b}=1$, otherwise.
\end{enumerate}

Suppose $\gamma$ is indeed $\alpha \times \beta$. Then, condition $p_{\gamma}'=p_{\gamma}$ will always hold. If $\gamma$ is a random element, then the probability that $p_{\gamma}'=p_{\gamma}$ is $1/2$. Therefore, the probability that $\mathcal{A}$ will guess the bit $b$ correctly is $3/4$, and the advantage is $1/4$ therefore. $\blacksquare$

\vspace{10pt}

Why is this necessary? Typically, it is impossible to prove the predicate ``for every efficient adversary $\mathcal{A}$ this probability is negligible'' and therefore we need to make assumptions, such as the Discrete Logarithm Assumption or the Computational Diffie-Hellman Assumption. In turn, proving the statement ``if $X$ is secure then $Y$ is also secure'' is manageable and does not require solving any fundamental problems. So, for example,
knowing that the probability of the adversary to break the Diffie-Hellman assumption is negligible, we can prove that the Diffie-Hellman key exchange is secure. 

\subsection{Basic Number Theory}

% todo add some intro word 
some intro word

\subsubsection{Introduction to number theory}

\begin{definition}
    An integer $a$ is divisible by a nonzero integer $b$, denoted $b \mid a$, or b is divisor of a, if and only if there exists an integer $k \in \mathbb{Z}$ such that $a = k \cdot b$.
\end{definition}

\begin{lemma}[Divisibility properties]
    For all $a, b, c \in \mathbb{Z}:$
    \hfill
    \begin{enumerate}
        \item $1 \mid a$
        \item $a \neq 0$, $a \mid a$
        \item $a \neq 0$, $a \mid 0$
        \item $b \mid a$, $c \mid b \Rightarrow c \mid a$
        \item $b \mid a \iff b \cdot c \mid a \cdot c$, $c > 0$
        \item $c \mid a$, $c \mid b  \Rightarrow c \mid (\alpha \cdot a \pm \beta \cdot b)$, $\text{for any } \alpha, \beta \in \mathbb{Z}$
    \end{enumerate}
\end{lemma}

You might wonder if there are cases where a number is not divisible by any integer, meaning there is no integer $k$ that satisfies the condition. Well, in such cases, a new theorem comes into play.

\begin{theorem}
    $\forall a, b \in \mathbb{Z}:$ $\exists!\, q, r$, where $q \in \mathbb{Z}$, $r \in \mathbb{N}$, $0 \leq r < |b|$, that $a = b \cdot q + r$.
\end{theorem}

To prove this theorem, all we need to prove is the existence and uniqueness of such a decomposition. Basically, this new theorem allows to define new operation that accept two integers and return two integers $q = \left\lfloor \frac{a}{b} \right\rfloor$, $r = a - b \cdot \left\lfloor \frac{a}{b} \right\rfloor$. Thus, $a \, \text{mod} \, b$ represents the remainder when $a$ is divided by $b$.

\vspace{10pt}

In division operations, it is common to check for any shared factors between two numbers. This is where the concept of the greatest common divisor (gcd) comes into.

\begin{definition}
    $\forall a, b \in \mathbb{Z}, \gcd(a, b) = d$ such that:
    \begin{enumerate}
        \item $d \mid a$, $d \mid b$
        \item $d  \in \mathbb{N}$ is a maximal integer that satisfies the first condition
    \end{enumerate}
\end{definition}

\begin{definition}
    Two numbers $a$ and $b$ \textbf{coprime} if and only if $\gcd(a, b) = 1$.
\end{definition}

\begin{lemma} [Greatest common divisor properties]
    \hfil
    \begin{enumerate}
        \item $\gcd(a, b) = b \iff b \mid a$
        \item $a \neq 0$, $\gcd(a, 0) = a$
        \item $\exists \delta$: $\delta \mid a, \delta \mid b \Rightarrow \delta \mid \gcd(a, b)$
        \item $c > 0$, $\gcd(a \cdot c, b \cdot c) = c \cdot \gcd(a, b)$
        \item $d = \gcd(a, b) \Rightarrow \gcd(\frac{a}{d}, \frac{b}{d}) = 1$
    \end{enumerate}
\end{lemma}

\begin{lemma}
    $\gcd(a, b) = \gcd(b, a - b)$
\end{lemma}

\begin{corollary}
    $\gcd(a, b) = \gcd(b, a \mod b)$
\end{corollary}

All these properties are interesting and useful, but you may wonder how to actually find $gcd(a, b)$. Euclidean algorithm is an efficient method for computing the greatest common divisor, and we will describe extended version, but later.

While the greatest common divisor (gcd) focuses on finding the largest shared factor between two numbers, the least common multiple (lcm) deals with finding the smallest multiple that both numbers have in common. The LCM is particularly useful when we need to synchronize cycles or work with fractions.

\begin{definition}
    $\forall a, b \in \mathbb{Z}, lcm(a, b) = m$ such that:
    \begin{enumerate}
        \item $a \mid m$, $a \mid m$
        \item $m \in \mathbb{N}$ is a maximal integer that satisfies the first condition 
    \end{enumerate}
\end{definition}

\begin{lemma} [Least common multiple properties]
    \hfil
    \begin{enumerate}
        \item $\lcm(a, 0)$ - undefined
        \item $\lcm(a, b) = a \iff b \mid a$
        \item $a, b$ - coprime $\Rightarrow \lcm(a, b) = a \cdot b$
        \item Any common divisor of $a$ and $b$ $\delta \mid \lcm(a, b)$
        \item $\forall c > 0: \lcm(a \cdot c, b \cdot b) =  c \cdot \lcm(a, b)$
        \item $\frac{\lcm(a, b)}{a}$ and $\frac{\lcm(a, b)}{b}$ - are coprime
    \end{enumerate}
\end{lemma}

\begin{theorem}
    $\forall a, b \in \mathbb{N}: \gcd(a, b) \cdot \lcm(a, b) = a \cdot b$
\end{theorem}

This theorem states that no additional algorithm is required for $\text{lcm}(a, b)$.

\begin{theorem}
    $\forall a, b \in \mathbb{N}: \gcd(a, b, c) = \gcd(\gcd(a, b), c) = \gcd(a, \gcd(a, b))$
\end{theorem}

\begin{theorem}
    $\forall a, b \in \mathbb{N}: \lcm(a, b, c) = \lcm(\lcm(a, b), c) = \lcm(a, \lcm(a, b))$
\end{theorem}

In conclusion, from these two theorems, we already know that there is no necessity for specific algorithms for $\gcd$ and $\lcm$ when dealing with many arguments. There are more specialized algorithms for each when considering a specific number of arguments, but unfortunately, such topics are beyond the scope of this book.

\subsubsection{Extended Euclidean algorithm}

In this section, we will introduce the Extended Euclidean Algorithm and an important lemma related to the GCD. You might have reasonable question why extended version. The simple answer is that it will later help us find inverse elements, which will be introduced in a subsequent section.

\begin{lemma} [Bezout identity]
    For all $a, b \in \mathbb{N}, d = \gcd(a, b) \; \exists u, v \in \mathbb{Z}, d = a \cdot u + b \cdot v$
\end{lemma}

\begin{corollary} [From Bezout identity]
    \hfill
    \begin{enumerate}
        \item $d = au + bv$, where one of the numbers is necessarily non-negative and the other is non-positive.
        \item $d = \gcd(a_1, a_2, \dots, a_n) \Rightarrow \exists \, u_1, u_2, \dots, u_n \in \mathbb{Z}: \, d = u_2 a_1 + u_2 a_2 + \dots + u_n a_n$
        \item For all $i \in \mathbb{N} \;\exists \, u_i, v_i \in \mathbb{Z}: r_i = a u_i + b v_i$
    \end{enumerate}    
\end{corollary}

The integers $u$ and $v$ are called coefficients Bezout. The first corollary seems obvious, because if all coefficients are non-negative, the result will be much larger than necessary, and if they are non-positive, the result must be negative, but the GCD $ \in \mathbb{N} $. The second consequence follows from the fact that we can decompose gcd thus sequentially derive this sequence. The last one stand that we can find coefficients Bezout on each euclidean algorithm step.

The extended Euclidean algorithm finds the Bezout coefficients together with the GCD.

\begin{algorithm}
    \caption{Extended Euclidean algorithm} \label{extended_euclidean_algorithm}
    \Input{$a, b \in \mathbb{N}, a \geq b$}
    \Output{$(gcd(a, b), \, u, \, v)$}
        
    $r_{0} \gets a; \, r_{1} \gets b$ \\ % todo fix format
    $u_{0} \gets 1; \, u_{1} \gets 0$ \\
    $v_{0} \gets 0; \, v_{1} \gets 1$ \\

    \For{$i \in \{1, \dots , \log(b) \}$}{
        $q_i \gets \lfloor r_{i-1} \, / \, r_{i} \rfloor$ \\
        $u_{i+1} \gets u_{i-1} - u_{i} q_i$ \\
        $v_{i+1} \gets v_{i-1} - v_{i} q_i$ \\
        $r_{i+1} \gets  a u_{i+1} + b v_{i}$ \\

        \If{$r_{i+1} = 0$}{
            \textbf{return} $(r_i, u_i, v_i)$
        }
    }
\end{algorithm}

Hence, we already know how the Extended Euclidean Algorithm works, but this method is not human-friendly. Next, example of a easy way to find the GCD.

% todo improve style
\begin{example} [Extended Euclidean algorithm example]
    \hfill

    First, we you need to find d = gcd(a,b), then, knowing this sequence of expansions, find the coefficients of Bezout, although this can be done simultaneously.

    \hfill

    \begin{minipage}{0.4\textwidth}
        \raggedright
        \vspace*{\fill}
            \begin{enumerate}
                \item $125 = 93 \cdot 1 + 32$
                \item $93 = 32 \cdot 2 + 29$
                \item $32 = 29 \cdot 1 + 3$
                \item $29 = 3 \cdot 9 + 2$
                \item $3 = 2 \cdot 1 + 1$
                \item $2 = 1 \cdot 2 + 0$        
            \end{enumerate}
        \vspace*{\fill}
    \end{minipage}
    \begin{minipage}{0.7\textwidth}
        \resizebox{0.7\textwidth}{!}{
            \begin{tabular}{|c|c|c|c|c|c|c|c|}
                \hline
                
                $i$   & $0$      & $1$ & $2$ & $3$ & $4$ & $5$ & $6$ \\
                
                \hline
                \hline

                $q_i$ & $\times$ & $1$ & $2$ & $1$ & $9$ & $1$ & $2$ \\
                
                \hline
                
                $u_i$ & $1$      & $0$ & $1$ & $-2$ & $3$ & $-29$ & $32$ \\
                \hline
                $v_i$ & $0$      & $1$ & $-1$ & $3$ & $-4$ & $ $ & $ $ \\
                
                \hline
            \end{tabular}
        }
    \end{minipage}

    \hfill
    
    Each corresponding cell is calculated with the following formula: \\
    $u_{i-1} - q_i u_i = u_{i+1}$ \\
    $v_{i-1} - q_i v_i = v_{i+1}$ 

    Knowing that, try to  finish this example. After finding $v_6$ and be sure to check yourself.
\end{example}

\subsubsection{Prime numbers}

Prime numbers are fundamental in mathematics due to their role as the building blocks of all natural numbers. Every integer greater than 1 can be uniquely factored into primes, a concept known as the Fundamental Theorem of Arithmetic, will be introduced nex section. This property makes primes central to number theory, and they play a crucial role in various mathematical proofs and structures.

\begin{definition}
    Number $n \in \mathbb{N}$ is prime $\iff n$ have only two divisors $1$ and $n$. 
\end{definition}

\begin{definition}
    Number $n \in \mathbb{N}$ is composite $\iff $ for all $a \in \mathbb{N}, 1 < a < n: a \mid n$.
\end{definition}

Therefore, in opposite of prime numbers, there are composite numbers, which are divisible by factors other than one and themselves.

\begin{remark}
    The number one is special, considered as not prime and not composite number.
\end{remark}

\begin{lemma}
    For all $n \in \mathbb{N}: \gcd(n, n+1) = 1$
\end{lemma}

\begin{theorem} [Euclidean theorem]
    If $A = \{p_1, p_2, p_3, \dots p_k\}$ - finite set, where $p_1$ is primes, then there exists a prime number such that $p \notin A$.
\end{theorem}

\begin{corollary}
    There is an infinite set of prime numbers.
\end{corollary}

But how do we know that for all $n \in \mathbb{N} \; \exists \, a$ - prime, $a \mid n$? Next Lemma states so. 

\begin{lemma}
    For all $n \in \mathbb{N}, n$ - composite, if $\exists \; d > 1$ - minimal divisor of n, then d - prime number.
\end{lemma}
% todo add proof

You may have a question or know something about the arrangement of prime numbers? 
How to check the prime number? 
For now there is no known efficient formula for primes, only asymptotic estimation.
For example this is reslut that says we can find at least one prime number in some parametrized range.
Also there are deterministics and probabilistic primality tests that answers second question, depends on tasks are solving.

Worth of mentioning, different forms of prime numbers also exists and have its application in some areas. For example Mersenne primes, Factorial primes, Euclid primes, Fibonacci primes and many others type of prime numbers.

\begin{definition} [Mersenne primes]
    $M_p = 2^p - 1$ - prime number $\Rightarrow p$ - prime number.
\end{definition}
% todo add proof
% todo add exmaple of biggest Mersenne primes

Mersenne primes, are important in both number theory and cryptography.
They have unique mathematical properties that make them useful for testing primality and generating large prime numbers.
Mersenne primes are also crucial in the construction of efficient algorithms for error correction in coding theory and for generating random numbers in cryptographic applications, etc. 
Beside, next theorem importan says that we can know the form of a prime numbers.

\begin{theorem} [Dirichlet's theorem]
    For any $a, b \in \mathbb{N}$ if $\gcd(a, b) = 1$, then infinite primes number form of $am + b$ exists, where $m \in \mathbb{N}$.
\end{theorem}

In other words, every infinite arithmetic progression whose first term and difference are positive integers contains an infinite number of primes.

% todo add exmaple of Dirichlet's theorem

\subsubsection{Fundamental theorem of arithmetic}
The Fundamental Theorem of Arithmetic states that every integer greater than 1 can be uniquely factored into primes, which is crucial for understanding the structure of numbers. 
It plays a key role in areas like number theory, cryptography, and simplifying calculations involving divisibility. 
But before formal description of the theorem, for better understanding is good to know following Lemma \ref{euclidean_lemma}.

\begin{lemma}[Euclidean lemma] \label{euclidean_lemma}
    If $p$ is a prime and $p \mid ab$, then $p \mid a$ or $p \mid b$.
\end{lemma}

\textbf{Proof.} 
$\blacktriangleright$
Let $p \mid ab$, but $ p \nmid a \Rightarrow \gcd(a, p) = 1 \Rightarrow \exists \; u, v: au + bv = 1 \Rightarrow abu + pbv = b$, but $p \mid ab$ and $p \mid p$, therefore $p \mid abu + pbv$. 
$\blacktriangleleft$

\begin{theorem}[Fundamental theorem of arithmetic]
    \hfill \\ 
    For all $n > 1, \, n \in \mathbb{N}: n~=~p_{1}^{\alpha_1} p_{2}^{\alpha_2} \dots p_{t}^{\alpha_t}$, where $p_i$ - primes and $\alpha_i > 0 \in \mathbb{N}$.
\end{theorem}

\textbf{Proof.} 
$\blacktriangleright$  
The theorem state equation then need to proof equation existence and uniqueness.
1) \textit{Existence}. 
Suppose that the statement of the theorem is false and there exist natural primes that do not have such a representation.
Let $n_0$ be the smallest of them.
If $n_0$ is prime it can be represented as $n_{0}^{1}$, which satisfies representation. Then $n_0$ must be composite, which means $\exists \, a, b : 1 < a, b < n_0 : n = ab$.
Since $n_0$ smallest non-decomposable number and $a, b < n_0$, then $a$ and $b$ can be represent as 
$a = p_{1}^{\alpha_{1}} \dots p_{t}^{\alpha_{t}}$, 
$b~=~q_{1}^{\beta{1}} \dots q_{k}^{\beta{k}} 
\Rightarrow~n_0~=~ab~=$ $=~p_{1}^{\alpha_{1}} \dots p_{t}^{\alpha_{t}} q_{1}^{\beta{1}} \dots q_{k}^{\beta{k}}$
$\Rightarrow$ contradiction. \\
2) \textit{Uniqueness}. Suppose such $n \in \mathbb{N}$, that have two different decompositions of a number 
$n = p_{1}^{\alpha_1} p_{2}^{\alpha_2} \dots p_{t}^{\alpha_t} = q_{1}^{\alpha_1} q_{2}^{\alpha_2} \dots q_{k}^{\alpha_k}
\Rightarrow p_1 \mid n \Rightarrow p \mid q_{1}^{\alpha_1} q_{2}^{\alpha_2} \dots q_{k}^{\alpha_k}$ 
According to Euclid's lemma~\ref{euclidean_lemma}, if the product of two numbers is divisible by a prime number $p$, then at least one of them is divisible by $p$.
$\Rightarrow \exists \, i: p_1 \mid q_{i}^{\beta_i}$, but $q_i$ is prime number $\Rightarrow q_i = p_i$, because can only be divided into itself or its degrees and among these divisors only $q_i$ is prime. 
Therefore, $p_i  = q_i$, now let's take $p2$, repeat the process and show that this number is also among these $q_i$ numbers.
But perhaps there are other primes $q_i$ and their powers among the numbers? No, because we can start from $q_1$ instead of $p_1$.
Hence, all numbers $p_{i}^{i}$  contains in set of $q_{i}^{i}$ vice~versa.
$\blacktriangleleft$

% \vspace{10pt}

% You may wonder why we need uniqueness proof, why existence is not enough? Answer: uniqueness does not work for everyone. 

% \begin{example}
%     Let take following subset $\{ \forall k \in \mathbb{N} \mid 4k +1 \}$ and as it turns out, the multiplication operation is closed for a given subset.
%     Moreover, it forms a group, if $k = 0$ number is identity element, etc. 
%     But the key point is that this group has its own "prime numbers". 
%     Among such numbers, it is easy to find numbers that have a non-unique representation in prime numbers. 
%     Among sequence  $5, 9, 13, 17, 21, 25, 29, \dots \text{ there  are "primes" } 5, 9, \dots, \text{, but } 25 \text{ is not}$.
%     $$441 = 21^2 = 9 \cdot 41$$
    
% \end{example}

\begin{corollary}
    \hfill

    \begin{enumerate}
        \item $d \mid n \Rightarrow d = p_{1}^{\beta_1}p_{2}^{\beta_2} \dots p_{t}^{\beta_t}$, where $0 \leq \beta_i \leq \alpha_i$
        \item $a = p_{1}^{\alpha_1} \dots p_{t}^{\alpha_t}, b = p_{1}^{\beta_1} \dots p_{t}^{\beta_t}$, $\alpha_i, \beta_i \geq 0 \Rightarrow \gcd(a, b) = \prod_{i=0}^{t}p^{\min(\alpha_i, \beta_i)}$
        \item $a = p_{1}^{\alpha_1} \dots p_{t}^{\alpha_t}, b = p_{1}^{\beta_1} \dots p_{t}^{\beta_t}$, $\alpha_i, \beta_i \geq 0 \Rightarrow \lcm(a, b) = \prod_{i=0}^{t}p^{\max(\alpha_i, \beta_i)}$
        \item $b \mid a, c \mid a, \gcd(b, c) = 1 \Rightarrow bc \mid a$
    \end{enumerate}
\end{corollary}

The implications and applications of the Fundamental Theorem of Arithmetic are very large and important, and a number of “obvious” ones are listed above.
However, you should also be aware that the problem of factorization, i.e., knowing the decomposition of a number into prime factors, is in a NP class (complexity) and is the basis of some cryptosystems, although it is gradually being abandoned, including due to the potential of quantum computers.

\subsubsection{Linear congruence}

\subsubsection{Modular multiplicative inverse}

\subsubsection{Chinese remainder theorem}

\subsubsection{Schwartz-Zippel Lemma}

\begin{lemma}\label{lemma:sz}
Let $\mathbb{F}$ be a field. Let $f(x_1, x_2, ..., x_n)$ be a polynomial of total degree $d$. Suppose that $f$ is not the zero polynomial. Let $S$ be
a finite subset of $\mathbb{F}$. Let $r_1, r_2, ... r_n$ be chosen at random uniformly and independently from $S$. Then the probability that 
$f(r_1, r_2, ..., r_n) = 0$ is $\le \frac{d}{|S|}$.
\end{lemma}

\begin{example}
Let $F = \F_3$, $f(x) = x^2 - 5x + 6$, $S = F$, $r \xleftarrow{R} \mathbb{F}_3$.

Schwartz-Zippel lemma says that the probability that $f(r) = 0$ is $\le \frac{2}{3}$.
\end{example}

Given two polynomials $P, Q$ with  degree $d$ in a field $\F_p$, for $r \xleftarrow{R} \mathbb{F}_3$: $\Pr[P(r) == Q(r)] \le \frac{d}{p}$.
For large fields, where  $\frac{d}{p}$ is negligible, this property allows to succinctly check the equality of polynomials.
Let $H(x) := P(x) - Q(x)$. Than for each $P(x) = Q(x) \rightarrow H(x) = 0$. Applying Schwartz-Zippel lemma, 
the probability of $H(x) = 0$ for $x \xleftarrow{R} \mathbb{F} $ is $\le \frac{d}{|S|}$.

\subsection{Exercises}

\textbf{Exercise 1.} Suppose that for the given cipher with a security parameter $\lambda$, the adversary $\mathcal{A}$ can deduce the least significant bit of the plaintext from the ciphertext. Recall that the advantage 
of a bit-guessing game is defined as $\text{SS}\mathsf{Adv}[\mathcal{A}] = \left|\Pr[b=\hat{b}] - \frac{1}{2}\right|$, where $b$ is the randomly chosen bit of a challenger, while 
$\hat{b}$ is the adversary's guess. What is the maximal advantage of $\mathcal{A}$ in this case?

\textbf{Hint:} The adversary can choose which messages to send to challenger to further distinguish the plaintexts.

\begin{enumerate}[a)]
    \item $1$
    \item $\frac{1}{2}$
    \item $\frac{1}{4}$
    \item $0$
    \item Negligible value ($\text{negl}(\lambda)$).
\end{enumerate}

\textbf{Exercise 2.} Consider the cipher $\mathcal{E} = (E,D)$ with encryption function $E: \mathcal{K} \times \mathcal{M} \to \mathcal{C}$ over the message space $\mathcal{M}$, ciphertext space $\mathcal{C}$, and key space $\mathcal{K}$. We want to define the security
that, based on the cipher, the adversary $\mathcal{A}$ cannot restore the message (\textit{security against message recovery}). For that reason, we define the following game:
\begin{enumerate}
    \item Challenger chooses random $m \xleftarrow{R} \mathcal{M}, k \xleftarrow{R} \mathcal{K}$.
    \item Challenger computes the ciphertext $c \gets E(k,m)$ and sends to $\mathcal{A}$.
    \item Adversary outputs $\hat{m}$, and wins if $\hat{m} = m$.
\end{enumerate}

We say that the cipher $\mathcal{E}$ is secure against message recovery if the \textbf{message recovery advantage}, denoted as $\text{MR}\textsf{adv}[\mathcal{A}, \mathcal{E}]$ is negligible. Which of the following statements is a valid interpretation of the message recovery advantage?
\begin{enumerate}[a)]
    \item $\text{MR}\textsf{adv}[\mathcal{A},\mathcal{E}] := \left|\text{Pr}[m=\hat{m}] - \frac{1}{2}\right|$
    \item $\text{MR}\textsf{adv}[\mathcal{A},\mathcal{E}] := \left|\text{Pr}[m=\hat{m}] - 1\right|$.
    \item $\text{MR}\textsf{adv}[\mathcal{A},\mathcal{E}] := \text{Pr}[m=\hat{m}]$
    \item $\text{MR}\textsf{adv}[\mathcal{A},\mathcal{E}] := \left|\text{Pr}[m=\hat{m}] - \frac{1}{|\mathcal{M}|}\right|$
\end{enumerate}

\textbf{Exercise 3.} Suppose that $f$ and $g$ are negligible functions. Which of the following functions is not neccessarily negligible?
\begin{enumerate}[a)]
    \item $f + g$
    \item $f \times g$
    \item $f - g$
    \item $f/g$
    \item $h(\lambda) := \begin{cases}
        1/f(\lambda) & \text{if } 0 < \lambda < 100000 \\
        g(\lambda) & \text{if } \lambda \geq 100000
    \end{cases}$
\end{enumerate}

\textbf{Exercise 4.} Suppose that $f \in \mathbb{F}_p[x]$ is a $d$-degree polynomial with $d$ \textbf{distinct} roots in $\mathbb{F}_p$. What is the probability that, when evaluating $f$ at $n$ random points, the polynomial will be zero at all of them?

\begin{enumerate}[a)]
    \item Exactly $(d/p)^n$.
    \item Strictly less that $(d/p)^n$.
    \item Exactly $nd/p$.
    \item Exactly $d/np$.
\end{enumerate}

\textbf{Exercise 5-6.} To demonstrate the idea of Reed-Solomon codes, consider the toy construction. Suppose that our message is a tuple of two elements $a,b \in \mathbb{F}_{13}$. Consider function $f: \mathbb{F}_{13} \to \mathbb{F}_{13}$, defined as $f(x) = ax+b$, and define the encoding of the message $(a,b)$ as $(a,b) \mapsto (f(0),f(1),f(2),f(3))$. 

\textbf{Question 5.} Suppose that you received the encoded message $(3,5,6,9)$. Which number from the encoded message is corrupted?
\begin{enumerate}[a)]
    \item First element ($3$).
    \item Second element ($5$).
    \item Third element ($6$).
    \item Fourth element ($9$).
    \item The message is not corrupted.
\end{enumerate}

\textbf{Question 6.} Consider the previous question. Suppose that the original message was $(a,b)$. Find the value of $a \times b$ (in $\mathbb{F}_{13}$).
\begin{enumerate}[a)]
    \item $4$
    \item $6$
    \item $12$
    \item $2$
    \item $1$
\end{enumerate}

\end{document}