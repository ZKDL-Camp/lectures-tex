\documentclass[../lecture-notes-148x210.tex]{subfiles}

\begin{document}

\subsection{Motivation}

Finally, we came to the most interesting part of the course: zero-knowledge proofs. Before we start with SNARKs, 
STARKs, Bulletproofs, and other zero-knowledge proof systems, let us first define what the zero-knowledge is. But even before 
that, we need to introduce some formalities. For example, what are ``proof'', ``witness'', and ``statement'' --- terms that are so widely used in zero-knowledge proofs.

Let us describe the typical setup. We have two parties: \textbf{prover} $\mathcal{P}$ and a \textbf{verifier} $\mathcal{V}$. The prover wants to convince the verifier that some statement is true. Typically, the statement is not obvious (well, that is the reason for building proofs after all!) and therefore there might be some ``helper'' data, called \textbf{witness}, that helps the prover to prove the statement. The reasonable question is whether the prover can simply send witness to verifier and call it a day. Of course since you are here, reading this lecture, it is obvious that the answer is no. More specifically, by introducing zk-SNARKs, STARKs, and other proving systems, we will try to mitigate the following issues:

\vspace{2mm}

\begin{itemize}
    \item \textbf{Zero-knowledge:} The prover wants to convince the verifier that the statement is true without revealing the witness. 
    \item \textbf{Argument of knowledge:} Moreover, typically we want to make sure that the verifier, besides the statement correctness, ensures that the prover \textbf{knows} such a witness related to the statement.
    \item \textbf{Succinctness:} The proof should be short, ideally logarithmic in the size of the statement. This is crucial for practical applications, especially in the blockchain space where we cannot allow to publish long proofs on-chain. Moreover, verification should be efficient as well.
\end{itemize}

\begin{example}
    Suppose, given a hash function\footnote{The notation $\{0,1\}^*$ means binary strings of arbitrary length} $H: \{0,1\}^* \to \{0,1\}^{\ell}$, the prover $\mathcal{P}$ wants to convince the verifier $\mathcal{V}$ that he knows the preimage $x \in \{0,1\}^*$ such that $H(x) = y$ for some given public value $y \in \{0,1\}^{\ell}$. The properties listed above are interpreted as follows:
    \begin{itemize}
        \item \textbf{Zero-knowledge:} The prover $\mathcal{P}$ does not want to reveal \textit{anything} about the pre-image $x$ to the verifier $\mathcal{V}$.
        \item \textbf{Argument of knowledge:} Given a string $y \in \{0,1\}^{\ell}$ it is not sufficient for a prover to merely state that $y$ has a pre-image. The prover $\mathcal{P}$ must demonstrate to a verifier $\mathcal{V}$ that he \textbf{knows} such a pre-image $x \in \{0,1\}^*$.
        \item \textbf{Succinctness:} If the hash function takes $n$ operations to compute\footnote{Note that ``number of operations'' is very vague term. One way to measure the ``size'' of some computational problem is specifying the number of gates in the arithmetical circuit $\mathtt{C}(x,w)$, representing the computation of this problem (denoted as $|\mathtt{C}|$, respectively).}, the proof should be \textbf{much} shorter than $n$ operations. State-of-art solutions can provide proofs that are $O((\log n)^c)$ (polylogarithmic) is size! Moreover, verification time of such proof is also typically polylogarithmic (or even $O(1)$ in some cases).
    \end{itemize}
\end{example}

\subsection{Relations and Languages}\label{section:relations_and_languages}
Recall that \textbf{relation} $\mathcal{R}$ is just a subset of $\mathcal{X} \times \mathcal{Y}$ for two arbitrary sets $\mathcal{X}$ and $\mathcal{Y}$. Now, we are going to introduce the notion of a \emph{language of true statements} based on $\mathcal{R}$.

\begin{definition}[Language of true statements]
    Let $\mathcal{R} \subseteq \mathcal{X} \times \mathcal{Y}$ be a relation. We say that a statement $x \in \mathcal{X}$ is a \textbf{true} statement if $(x,y) \in \mathcal{R}$ for some $y \in \mathcal{Y}$, otherwise the statement is called \textbf{false}. We define by $\mathcal{L}_{\mathcal{R}}$ (the language over relation $\mathcal{R}$) the set of all true statements, that is:
    \begin{equation*}
        \mathcal{L}_{\mathcal{R}} = \{ x \in \mathcal{X}: \exists y \in \mathcal{Y} \; \text{such that} \; (x,y) \in \mathcal{R} \}.
    \end{equation*}
\end{definition}

Now, what is the purpose of introducing relations and languages? The idea is that relation is a natural way to formalize the notion of a statement and witness. Namely, we denote the elements of $\mathcal{X}$ as statements and the elements of $\mathcal{Y}$ as witnesses.

Further, we denote by $w$ the witness for the statement $x \in \mathcal{L}_{\mathcal{R}}$. Oftentimes, one might also encounter notation $\phi$ to denote the statement, but we will stick to $x$ for simplicity.

\begin{example}
    Suppose we want to prove the following claim: number $n \in \mathbb{N}$ is the product of two large prime numbers $(p,q) \in \mathbb{N} \times \mathbb{N}$. Here, the relation is the following:
    \begin{equation*}
        \mathcal{R} = \{ (n, p, q) \in \mathbb{N}^3: n = p \cdot q \; \text{where $p,q$ are primes} \}
    \end{equation*}

    In this particular case, the language of true statements is defined as 
    \begin{equation*}
        \mathcal{L}_{\mathcal{R}} = \{n \in \mathbb{N}: \exists p,q \; \text{are primes such that}\; n = pq\}
    \end{equation*}
    
    Therefore, our initial claim we want to prove is $n \in \mathcal{L}_{\mathcal{R}}$. The witness for this statement is the pair $(p,q)$, where $p$ and $q$ are prime numbers such that $n = p \cdot q$ and typically (but not always) we want to prove this without revealing our witness: $p$ and $q$. For example, one valid witness for $n = 15$ is $(3,5)$, while $n=16$ does not have any valid witness, so $16 \not\in \mathcal{L}_{\mathcal{R}}$.
\end{example}

\begin{example}
    Another example of claim we want to prove is the following: number $x \in \mathbb{Z}_N^{\times}$\footnote{By $\mathbb{Z}_N^{\times}$ we denote the multiplicative group of integers modulo $N$. In other words, this is a set of integers $\{x \in \mathbb{Z}_N: \gcd \{x, N\} = 1\}$.} is a \textbf{quadratic residue} modulo $N$, meaning there exists some $w \in \mathbb{Z}_N^{\times}$ such that $x \equiv w^2 \pmod{N}$ (naturally, $w$ is called a \textit{square root} of $x$). The relation in this case is:
    \begin{equation*}
        \mathcal{R} = \{ (x, w) \in (\mathbb{Z}_N^{\times})^2: x \equiv w^2 \pmod{N} \}
    \end{equation*}

    In this case, $\mathcal{L}_{\mathcal{R}} = \{x \in \mathbb{Z}_N^{\times}: \exists w \in \mathbb{Z}_N^{\times} \; \text{such that} \; x \equiv w^2 \pmod{N}\}$. Here, our square root of $x$ modulo $N$, that is $w$, is the witness for the statement $x \in \mathcal{L}_{\mathcal{R}}$. For example, for $N=7$ we have $4 \in \mathcal{L}_{\mathcal{R}}$ since $5$ is a valid witness: $5^2 \equiv 4 \pmod{7}$, while $3 \not\in \mathcal{L}_{\mathcal{R}}$ since there is no valid witness for $3$.
\end{example}

However, we want to limit ourselves to languages that has reasonably efficient verifier (since otherwise the problem is not really practical and therefore of little interest to us). For that reason, we define the notion of a \emph{NP Language} and from now on, we will be working with such languages.

\begin{definition}[NP Language]
    A language $\mathcal{L}_{\mathcal{R}}$ belongs to the NP class if there exists a polynomial-time verifier $\mathcal{V}$ such that the following two properties hold:
    \begin{itemize}
        \item \textbf{Completeness:} If $x \in \mathcal{L}_{\mathcal{R}}$, then there is a witness $w$ such that $\mathcal{V}(x, w) = 1$ with $|w| = \mathsf{poly}(|x|)$. Essentially, it states that true claims have \textit{short}\footnote{``Short'' is a pretty relative term which would further differ based on the context. Here, we assume that the proof is ``short'' if it can be computed in polynomial time. However, in practice, we will want to make the proofs even shorter: see SNARKs and STARKs.} proofs.
        \item \textbf{Soundness:} If $x \not\in \mathcal{L}_{\mathcal{R}}$, then for any $w$ it holds that $\mathcal{V}(x, w) = 0$. Essentially, it states that false claims have no proofs.
    \end{itemize}
\end{definition}

However, this construction on its own is not helpful to us. In particular, without having any randomness and no interaction, building practical proving systems is very hard. Therefore, we need some more ingredients to make proving NP statements easier.

\subsection{Interactive Probabilistic Proofs}

As mentioned above, we will bring two more ingredients to the table: \textbf{randomness} and \textbf{interaction}:
\begin{itemize}
    \item \textbf{Interaction:} rather than simply passively receiving the proof, the verifier $\mathcal{V}$ can interact with the prover $\mathcal{P}$ by sending challenges and receiving responses.
    \item \textbf{Randomness:} verifier can send random coins (challenges) to the prover, which the prover can use to generate responses.
\end{itemize}

\begin{remark}
    For those who have already worked with SNARKs, the above introduction might seem very confusing. After all, what we are aiming for is to build \textbf{non-interactive} zero-knowledge proofs. However, as it turns out, there are a plenty of ways to make \textit{some} interactive proofs non-interactive. We will discuss this in more detail later.
\end{remark}

Now, one of the drastic changes is the following: if $x \not\in \mathcal{L}_{\mathcal{R}}$, then the verifier $\mathcal{V}$ should reject the claim with overwhelming\footnote{Some technicality: as you know from the Lecture 2, the value $\varepsilon = \mathsf{negl}(\lambda)$ is called negligible since it is very close to $0$. In turn, the value $1-\varepsilon$ is called \textit{overwhelming} since it is close to $1$.} probability (in contrast to strict probability of $1$). Let us consider the concrete example.

\subsubsection{Example: Quadratic Residue Test}\label{section:quadratic_residue_test}

Again, suppose for relation $\mathcal{R} = \{(x,w) \in (\mathbb{Z}_N^{\times})^2: x \equiv w^2 \pmod{N}\}$ and corresponding language $\mathcal{L}_{\mathcal{R}} = \{x \in \mathbb{Z}_N^{\times}: \exists w \in \mathbb{Z}_N^{\times} \; \text{such that} \; x \equiv w^2 \pmod{N}\}$ the prover $\mathcal{P}$ wants to convince the verifier that the given $x$ is in language $\mathcal{L}_{\mathcal{R}}$. Again, sending $w$ is not an option, as we want to avoid revealing the witness. So how can we proceed? The idea is that the prover $\mathcal{P}$ should prove that he \textit{could} prove it if he felt like it. 

So here how it goes. The prover $\mathcal{P}$ can first sample a random $r \xleftarrow{R} \mathbb{Z}_N^{\times}$, calculate $a \gets r^2 \pmod{N}$ and say to the verifier $\mathcal{V}$: 
\begin{itemize}
    \item Hey, I could give you the square roots of both $a$ and $ax \pmod{N}$ and that would convince you that the statement is true! But in this case, you would know $w$\footnote{If verifier gets both $r$ and $rw \pmod{N}$, he can divide the latter by former and get $w$}.
    \item So instead of providing both values simultaneously, you will choose which one you want to see: either $r$ or $r\times w\pmod{N}$. This way, after a couple of such rounds, you will not learn $w$ but you will be convinced that I know it.
\end{itemize}

That being said, formally the interaction between prover $\mathcal{P}$ and verifier $\mathcal{V}$ can be described as follows:
\begin{enumerate}
    \item $\mathcal{P}$ samples $r \xleftarrow{R} \mathbb{Z}_N^{\times}$ and sends $a \gets r^2 \pmod{N}$ to $\mathcal{V}$.
    \item $\mathcal{V}$ sends a random bit $b \xleftarrow{R} \{0,1\}$ to $\mathcal{P}$.
    \item If $b=0$, the prover sends $z \gets r$, otherwise, if $b=1$, he sends $z \gets rw \pmod{N}$.
    \item The verifier checks whether $z^2 \equiv a\times x^{b} \pmod{N}$.
    \item Repeat the process for $\lambda \in \mathbb{N}$ rounds.
\end{enumerate}

\begin{figure}[H]
    \centering
    \scalebox{0.8}{
    \begin{tikzpicture}
        \node[inner sep=0pt, align=center] (prover) {\includegraphics[width=1.25cm]{lectures/images/common/prover.png}\\Prover $\mathcal{P}$};
        \node[inner sep=0pt, align=center, right=5cm of prover] (verifier) {\includegraphics[width=1.25cm]{lectures/images/common/verifier.png}\\Verifier $\mathcal{V}$};

        \draw [dashed,line width=0.3mm] ([yshift=-0.5cm]prover.south) -- ([yshift=-11cm]prover.south);
        \draw [dashed,line width=0.3mm] ([yshift=-0.5cm]verifier.south) -- ([yshift=-11cm]verifier.south);

        \node[align=center,fill=white!5,thick,below=0.5cm of prover](prover-setup){
        \noindent\rule{3.5cm}{0.8pt}\\
        $r \xleftarrow{R} \mathbb{Z}_N^{\times}$ \\
        $a \gets r^2 \pmod{N}$ \\
        \noindent\rule{3.5cm}{0.8pt}};

        \draw[-{Stealth[length=3mm]},line width=0.4mm] ([yshift=-3.25cm]prover.south) coordinate (l2)--(l2-|verifier) node[midway, above=2mm, fill=white]{Send $a$};

        \node[align=center,fill=white!5,thick,below=4cm of verifier](verifier-choice){
        \noindent\rule{3.5cm}{0.8pt}\\
        I am choosing a bit! \\
        $b \xleftarrow{R} \{0,1\}$ \\
        \noindent\rule{3.5cm}{0.8pt}};

        \draw[-{Stealth[length=3mm]},line width=0.4mm] ([yshift=-6.5cm]verifier.south) coordinate (l2)--(l2-|prover) node[midway, above=2mm, fill=white]{Send $b$};

        \node[align=center,fill=white!5,thick,below=7.5cm of prover](prover-setup){
        \noindent\rule{3.5cm}{0.8pt}\\
        If $b=0$, send $z \gets r$ \\
        If $b=1$, send $z \gets w \times r \pmod{N}$ \\
        \noindent\rule{3.5cm}{0.8pt}};

        \draw[-{Stealth[length=3mm]},line width=0.4mm] ([yshift=-10cm]prover.south) coordinate (l2)--(l2-|verifier) node[midway, above=2mm, fill=white]{Send $z$};

        \node[align=center,fill=white!5,thick,below=10.5cm of verifier](verifier-choice){
        \noindent\rule{3.5cm}{0.8pt}\\
        Verify $z^2 \equiv a \times x^{b} \pmod{N}$ \\
        \noindent\rule{3.5cm}{0.8pt}};
    \end{tikzpicture}
    }

    \caption{The interactive protocol between prover $\mathcal{P}$ and verifier $\mathcal{V}$ for the quadratic residue test.}
\end{figure}

Now, let us show that the provided protocol is indeed \textbf{complete} and \textbf{sound}.

\textbf{Completeness.} Suppose the verifier chose $b=0$ and thus the prover has sent $z=r$. The check would be $r^2 \equiv a\times x^{0} \pmod{N}$ which is equivalent to $r^2 \equiv a \pmod{N}$. This obviously holds. 

If, in turn, the verifier chose $b=1$ and the prover sent $rw$, the check would be $(rw)^2 \equiv ax^{1-0} \pmod{N}$ which is equivalent to $r^2w^2 \equiv ax \pmod{N}$. Since $a = r^2 \pmod{N}$ and $x = w^2 \pmod{N}$, this check also obviously holds.

\textbf{Soundness.} Here, we need to prove that for any dishonest prover who does not know $w$, the verifier will reject the claim with overwhelming probability. One can show the following, which we are not going to prove (yet, this is quite easy to show):

\begin{proposition}
    If $x \not\in \mathcal{L}_{\mathcal{R}}$, then for any prover $\mathcal{P}$, the verifier $\mathcal{V}$ will reject the claim with probability at least $1/2$.
\end{proposition}

By making $\lambda$ rounds, the probability of rejection is $\left(\frac{1}{2}\right)^{\lambda} = \mathsf{negl}(\lambda)$ and therefore the verifier can be convinced that $x \in \mathcal{L}_{\mathcal{R}}$ with overwhelming probability of $1-2^{-\lambda}$.

To denote the interaction between algorithms $\mathcal{P}$ and $\mathcal{V}$ on the statement $x$, we use notation $\langle \mathcal{P}, \mathcal{V} \rangle(x)$. Finally, now we are ready to define the notion of an \textbf{interactive proof system}.

\begin{definition}
    A pair of algorithms $(\mathcal{P},\mathcal{V})$ is called an \textbf{interactive proof} for a language $\mathcal{L}_{\mathcal{R}}$ if $\mathcal{V}$ is a polynomial-time verifier and the following two properties hold:
    \begin{itemize}
        \item \textbf{Completeness:} For any $x \in \mathcal{L}_{\mathcal{R}}$, $\text{Pr}[\langle \mathcal{P}, \mathcal{V} \rangle(x) = \mathsf{accept}]=1$.
        \item \textbf{Soundness:} For any $x \not\in \mathcal{L}_{\mathcal{R}}$ and for any prover $\mathcal{P}^*$, we have 
        \begin{equation*}
            \text{Pr}[\langle \mathcal{P}^*, \mathcal{V} \rangle(x) = \mathsf{accept}] \leq \mathsf{negl}(\lambda)
        \end{equation*}
    \end{itemize}
\end{definition}

\begin{definition}
    Besides classes \textbf{P} and \textbf{NP}, we now have one more class: \textbf{the class of interactive proofs} (\textbf{IP}):
    \begin{equation*}
        \mathbf{IP} = \{\mathcal{L}: \text{there is an interactive proof $(\mathcal{P}, \mathcal{V})$ for $\mathcal{L}$}\}.
    \end{equation*}
\end{definition}

\subsection{Zero-Knowledge}

Turns out that defining the zero-knowledge to even such a simplistic interactive proof system is not that easy. Informally, we give the following definition.

\begin{definition}
    An interactive proof system $(\mathcal{P}, \mathcal{V})$ is called \textbf{zero-knowledge} if for any polynomial-time verifier $\mathcal{V}^*$ and any $x \in \mathcal{L}_{\mathcal{R}}$, the interaction $\langle \mathcal{P}, \mathcal{V}^* \rangle(x)$ gives nothing new about the witness $w$.
\end{definition}

\begin{definition}
    The pair of algorithms $(\mathcal{P}, \mathcal{V})$ is called a \textbf{zero-knowledge interactive protocol} if it is \textit{complete}, \textit{sound}, and \textit{zero-knowledge}.
\end{definition}

\vspace{-1mm}

Basically, the specified interaction is a \textbf{proof}! The prover $\mathcal{P}$ can convince the verifier $\mathcal{V}$ that the statement is true without revealing the witness -- that is what we need (quite of).

\vspace{-1mm}

\begin{remark}
    The above definition is very informal and, for the most part, complete for the purposes of this course. If you do not want to dive into the formalities, you can skip the next part of this section. However, if you are curious about some technicalities, feel free to continue reading.
\end{remark}

\subsubsection{The Verifier's View}
Suppose that the interaction between $\mathcal{V}$ and $\mathcal{P}$ has ended with the successful verification. What has $\mathcal{V}$ learned? Well, first things first, he has learned that the statement is true, that is $x \in \mathcal{L}_{\mathcal{R}}$. However, he has also learned something more: he has learned the transcript of the interaction, that is the sequence of messages between $\mathcal{P}$ and $\mathcal{V}$.

\vspace{-1mm}

\begin{definition}
    Interaction between $\mathcal{P}$ and $\mathcal{V}$ consists of prover's messages (e.g., commitments and responses) $(m_1,m_2,\dots,m_{\ell})$, verifier's queries $(q_1,q_2,\dots,q_{\ell})$, and $\mathcal{V}$'s random coins $(r_1,r_2,\dots,r_{\ell})$. The view of the verifier $\mathcal{V}$, denoted as $\mathsf{view}_{\mathcal{V}}(\mathcal{P},\mathcal{V})[x]$, is a random variable $(m_1,r_1,q_1,m_2,r_2,q_2,\dots,m_{\ell},r_{\ell},q_{\ell})$ that is determined by the random coins of $\mathcal{V}$ and the messages of $\mathcal{P}$ after the interaction with the statement $x$. See Figure below.
\end{definition}

\vspace{-3mm}

\begin{example}
    Suppose that for the aforementioned protocol with $N=3 \times 2^{30} + 1$, the conversation between the prover $\mathcal{P}$, who wants to convince that $1286091780 \in \mathcal{L}_R$, and $\mathcal{V}$ is the following:
    \begin{enumerate} %[left=0.3em]
        \item During the first round, $\mathcal{P}$ sends $672192003$ to $\mathcal{V}$.
        \item $\mathcal{V}$ sends $b=0$ to $\mathcal{P}$.
        \item $\mathcal{P}$ sends $2606437826$ to $\mathcal{V}$.
        \item $\mathcal{V}$ verifies that indeed $2606437826^2 \equiv 672192003 \pmod{N}$.
        \item During the second round, $\mathcal{P}$ sends $2619047580$ to $\mathcal{V}$.
        \item $\mathcal{V}$ chooses $b=1$ and sends to $\mathcal{P}$.
        \item $\mathcal{P}$ sends $1768388249$ to $\mathcal{V}$.
        \item $\mathcal{V}$ verifies that $1768388249^2 \equiv 2619047580 \times 1286091780~\pmod{N}$.
        \item Conversation ends.
    \end{enumerate}

    The view of the verifier $\mathcal{V}$ is the following: 
    \begin{equation*}
        \scalebox{0.85}{
            $\mathsf{view}_{\mathcal{V}}(\mathcal{V}, \mathcal{P})[1286091780] = (672192003, 0, 2606437826, 2619047580, 1, 1768388249)$
        }
    \end{equation*}

    Essentially, the view that you currently has witnessed is the same as one that $\mathcal{V}$ has seen. After this interaction, you have not learned anything about the witness $w$ that prover $\mathcal{P}$ knows and which we, as of now, has not revealed to you.

    In fact, you can verify by yourself, that the witness was $w = 3042517305$ and two randomnesses were $r_1 = 2606437826$ and $r_2 = 3023142760$.

    One final note that is essential for the further discussion: variable $\mathsf{view}_{\mathcal{V}}(\mathcal{P}, \mathcal{V})[x]$ is a random variable. For example, for our particular case, both bits could be $0$ or both bits could be $1$. 
\end{example}

\begin{figure}[H]
    \centering
    \scalebox{0.95}{
    \begin{tikzpicture}
        \node[inner sep=0pt, align=center] (prover) {\includegraphics[width=1.25cm]{lectures/images/common/prover.png}\\Prover $\mathcal{P}$};
        \node[inner sep=0pt, align=center, right=5cm of prover] (verifier) {\includegraphics[width=1.25cm]{lectures/images/common/verifier.png}\\Verifier $\mathcal{V}$};

        \draw [dashed,line width=0.3mm] ([yshift=-0.5cm]prover.south) -- ([yshift=-8cm]prover.south);
        \draw [dashed,line width=0.3mm] ([yshift=-0.5cm]verifier.south) -- ([yshift=-8cm]verifier.south);

        \draw[-{Stealth[length=3mm]},line width=0.4mm] ([yshift=-1.5cm]prover.south) coordinate (l2)--(l2-|verifier) node[midway, above=0mm, fill=white]{Send $m_1$};

        \draw[-{Stealth[length=3mm]},line width=0.4mm] ([yshift=-2.5cm]verifier.south) coordinate (l2)--(l2-|prover) node[midway, above=0mm, fill=white]{Toss coin $r_1$ and send query $q_1$};

        \draw[-{Stealth[length=3mm]},line width=0.4mm] ([yshift=-3.5cm]prover.south) coordinate (l2)--(l2-|verifier) node[midway, above=0mm, fill=white]{Send $m_2$};

        \draw[-{Stealth[length=3mm]},line width=0.4mm] ([yshift=-4.5cm]verifier.south) coordinate (l2)--(l2-|prover) node[midway, above=0mm, fill=white]{Toss coin $r_2$ and send query $q_2$};
        
        \draw[-{Stealth[length=3mm]},line width=0.4mm] ([yshift=-6.5cm]prover.south) coordinate (l2)--(l2-|verifier) node[midway, above=0mm, fill=white]{Send $m_{\ell}$};

        \draw[-{Stealth[length=3mm]},line width=0.4mm] ([yshift=-7.5cm]verifier.south) coordinate (l2)--(l2-|prover) node[midway, above=0mm, fill=white]{Toss coin $r_{\ell}$ and send query $q_{\ell}$};
        
    \end{tikzpicture}
    }

    \caption{The interactive protocol between prover $\mathcal{P}$ and verifier $\mathcal{V}$. Prover's messages consist of messages $\{m_k\}_{k=1}^{\ell}$, verifier's messages consist of queries $\{q_k\}_{k=1}^{\ell}$, and additionally verifier samples random coins $\{r_k\}_{k=1}^{\ell}$.}
\end{figure}

\subsubsection{The Simulation Paradigm}

The key idea is the following: $\mathsf{view}_{\mathcal{V}}(\mathcal{V}, \mathcal{P})[x]$ gives nothing new to the verifier $\mathcal{V}$ about the witness $w$. But it gives nothing new, if he could have \textit{simulated} this view on his own, without even running the interaction. In other words, the ``simulated'' and ``real'' views should be \textit{computationally-indistinguishable}. But let us define the computational indistinguishability first.

\begin{definition}[Computational Indistinguishability]
    Given two random distributions $D_0$ and $D_1$, define the following challenger-adversary game:
    \begin{enumerate}
        \item The challenger randomly samples $x_0 \xleftarrow{R} D_0, x_1 \xleftarrow{R} D_1$ and a bit $b \xleftarrow{R} \{0,1\}$.
        \item The challenger sends $(x_0, x_1, b)$ to the adversary.
        \item The adversary $\mathcal{A}$ outputs a bit $\hat{b}$.
    \end{enumerate}

    We define the advantage of the adversary $\mathcal{A}$ in distinguishing $D_0$ and $D_1$ as 
    \begin{equation*}
        \text{Ind}\textsf{adv}[\mathcal{A}, D_0, D_1] = \left|\text{Pr}[b = \hat{b}] - \frac{1}{2}\right|
    \end{equation*}

    Distributions $D_0$ and $D_1$ are called \textbf{computationally indistinguishable}, denoted as $D_0 \approx D_1$, if for any polynomial-time adversary $\mathcal{A}$ and polynomial number of rounds in the game, the advantage $\text{Ind}\textsf{adv}[\mathcal{A}, D_0, D_1]$ is negligible.
\end{definition}

Finally, we are ready to define the \textbf{zero-knowledge}.

\begin{definition}[Zero-Knowledge]
    An interactive protocol $(\mathcal{P}, \mathcal{V})$ is \textbf{zero-knowledge} for a language $\mathcal{L}_{\mathcal{R}}$ if for every poly-time verifier $\mathcal{V}^*$ there exists a poly-time simulator $\mathsf{Sim}$ such that for any valid statement $x \in \mathcal{L}_{\mathcal{R}}$:
    \begin{equation*}
        \mathsf{view}_{\mathcal{V}^*}(\mathcal{P}, \mathcal{V}^*)[x] \approx \mathsf{Sim}(x)
    \end{equation*}
\end{definition}

However, the condition that verifier might be arbitrary is rather strong. Therefore, we introduce the notion of \textbf{honest-verifier zero-knowledge}.

\begin{definition}{Honest-Verifier Zero-Knowledge (HVZK)}
    An interactive protocol $(\mathcal{P}, \mathcal{V})$ is \textbf{honest-verifier zero-knowledge} for a language $\mathcal{L}_{\mathcal{R}}$ if there exists a probabilistic poly-time simulator $\mathsf{Sim}$ such that for any valid statement $x \in \mathcal{L}_{\mathcal{R}}$\footnote{Below, we assume that the verifier $\mathcal{V}$ is honest: he is following the protocol.}:
    \begin{equation*}
        \mathsf{view}_{\mathcal{V}}(\mathcal{P}, \mathcal{V})[x] \approx \mathsf{Sim}(x)
    \end{equation*}
\end{definition}

\subsection{Proof of Knowledge}

Now, the main issue with the above definition is that \textit{we have proven the statement correctness, but we have not proven that the prover \textbf{knows} the witness}. These are completely two different things. Let us demonstrate why.

\begin{example}
    Suppose that the prover $\mathcal{P}$ wants to convince the verifier that he knows the discrete logarithm of a given point $P \in E(\mathbb{F}_p)$ on a cyclic elliptic curve $E(\mathbb{F}_p)$ of order $r$. This corresponds to the relation and the corresponding language:
    \begin{align*}
        \mathcal{R} = \{(P, \alpha) \in E(\mathbb{F}_p) \times \mathbb{Z}_r: P = [\alpha] G\}, \\ \mathcal{L}_{\mathcal{R}} = \{P \in E(\mathbb{F}_p): \exists \alpha \in \mathbb{Z}_r \; \text{such that} \; P = [\alpha] G\}
    \end{align*}

    But here is the catch: actually, $\mathcal{L}_{\mathcal{R}} = E(\mathbb{F}_p)$ since any point $P$ has a witness $\alpha$ such that $P = [\alpha] G$ (recall that the curve is cyclic)! So proving that $P \in \mathcal{L}_{\mathcal{R}}$ is completely useless! Rather, we want to prove that the prover knows $\alpha$, not the fact that the point has a discrete logarithm.
\end{example}

That is why instead of \textbf{proof}, we need a \textbf{proof of knowledge}. This leads to even another weird paradigm used for the rigorous definition: the \textbf{extractor}. Basically, the knowledge of witness means that we can \textit{extract} the witness while interacting with the prover. Yet, the \textit{extractor} can do more than the verifier: he can call the prover however he wants and he can also rewind the prover (for example, run some pieces multiple times). This sometimes is referred to as ``extractor $\mathcal{E}$ uses $\mathcal{P}$ as an oracle''. 
Now, let us move to the formal definition.

\begin{definition}[Proof of Knowledge]
    The interactive protocol $(\mathcal{P}, \mathcal{V})$ is a \textbf{proof of knowledge} for $\mathcal{L}_{\mathcal{R}}$ if exists a poly-time extractor algorithm $\mathcal{E}$ such that for any valid statement $x \in \mathcal{L}_{\mathcal{R}}$, in expected poly-time $\mathcal{E}^{\mathcal{P}}(x)$ outputs $w$ such that $(x,w) \in \mathcal{R}$.
\end{definition}

\begin{lemma}
    The protocol from \Cref{section:quadratic_residue_test} is a proof of knowledge for the language $\mathcal{L}_{\mathcal{R}}$. 
\end{lemma}

\textbf{Proof.} Let us define the extractor $\mathcal{E}$ for the statement $x$ as follows:
\begin{enumerate}
    \item Run the prover to receive $a \equiv r^2 \pmod{N}$ ($r$ is chosen randomly from $\mathbb{Z}_N^*$).
    \item Set verifier's message to $b=0$ to get $z_1 \gets r$.
    \item \textbf{Rewind} and set verifier's message to $b=1$ to get $z_2 \gets rw \pmod{N}$.
    \item Output $z_2/z_1 \pmod{N}$
\end{enumerate}

The extractor $\mathcal{E}$ will always output $w$ if $x \in \mathcal{L}_{\mathcal{R}}$. $\hfill\Box$

\begin{remark}
    Note that extractor is given much more than the verifier: he can call the prover multiple times and he can also rewind the prover. This is the main difference between the verifier and the extractor.    
\end{remark}

\subsection{Fiat-Shamir Heuristic}

\subsubsection{Random Oracle}

In cryptography, one frequently encounters the term \textit{cryptographic oracle}. In this section, we are not going to dive into the technical details of what that is, yet it is useful to have a general understanding of what it is.

\begin{definition}[Cryptographic Oracle]
    Informally, \textit{cryptographic oracle} is simply a function $\mathcal{O}$ that gives in $O(1)$ an answer to some typically very hard problem.     
\end{definition}

\begin{example}
    Consider the Computational Diffie-Hellman (CDH) problem on the cyclic elliptic curve $E(\mathbb{F}_p)$ of prime order $r$ with a generator $G$. Recall that such problem consists in computing $[\alpha\beta]G$ given $[\alpha]G$ and $[\beta]G$ where $\alpha,\beta \in \mathbb{Z}_r$. 

    Typically, it is believed that the Diffie-Hellman problem is hard (meaning, for any adversary strategy the probability of solving the problem is negligible). However, we \textit{could} assume that such problem can be solved in $O(1)$ by a cryptographic oracle $\mathcal{O}_{\text{CDH}}: ([\alpha]G,[\beta]G) \mapsto [\alpha\beta]G$. This way, we can rigorously prove the security of some cryptographic protocols \textit{even} if the Diffie-Hellman problem is suddenly solved. 
\end{example}

One of the most popular cryptographic oracles is the \textbf{random oracle} $\mathcal{O}_{\text{R}}$. Let us define how the random oracle works.

Suppose someone is inputting $x$ to the random oracle $\mathcal{O}_{\text{R}}$. The oracle $\mathcal{O}_{\text{R}}$ does the following:
\begin{enumerate}
    \item If $x$ has been queried before, the oracle returns the same value as it returned before.
    \item If $x$ has not been queried before, the oracle returns a randomly uniformly sampled value from the output space.
\end{enumerate}

\begin{remark}
    Of course, the sudden appearance of the random oracle is not a magic trick. In practice, the random oracle is typically implemented as a hash function. Of course, formally, the hash function is not a random oracle, yet it is a very good approximation and it is reasonable to assume that the hash function behaves like a random oracle.
\end{remark}

\subsubsection{Fiat-Shamir Transformation}

Now, the main issue with the interactive proofs is that they are\ldots Well, \textit{interactive}. Ideally, we simply want to accumulate a proof $\pi$, publish it (say, in blockchain) so that anyone (essentially, being the verifier) could check its validity. So we need some tools to make \textit{some} interactive protocols non-interactive. This is, of course, not always possible, but there are some ways to achieve this.

While different protocols use different ways to achieve this, one of the most popular methods (which, in particular, is used in STARKs) is the \textbf{Fiat-Shamir heuristic}. The idea is the following: instead of verifier sending the challenges, we can replace them with the random oracle applied to all the previous messages. 

Here how it goes. Suppose we have an interactive protocol $(\mathcal{P}, \mathcal{V})$ for the statement $x$. As previously defined, the interaction between $\mathcal{P}$ and $\mathcal{V}$ consists of prover's messages $(m_1,m_2,\dots,m_{\ell})$, verifier's queries $(q_1,q_2,\dots,q_{\ell})$, and verifier's random coins $(r_1,r_2,\dots,r_{\ell})$. In case all the queries are public random coins, such interactive protocol is called \textbf{public-coin protocol} (or, more formally, \textbf{Arthur-Merlin protocol}). However, as it turns out, when all the verifier's queries are simply uniformly sampled random values, it is an overkill to use the interactive protocol. Instead, suppose at some point the verifier got messages $m_1,m_2,\dots,m_{\ell'}$ ($\ell' \leq \ell$) from the prover. Then, instead of verifier sampling some random value $r_{\ell'}$, we can simply use the random oracle $\mathcal{O}_{\text{R}}$ as follows: $r_{\ell'} \gets \mathcal{O}_{\text{R}}(x,m_1,m_2,\dots,m_{\ell'})$. Practically, instead of random oracle $\mathcal{O}_{\text{R}}$ we use the hash function $H$, and use: $r_{\ell'} \gets H(x \parallel m_1 \parallel m_2 \parallel \dots \parallel m_{\ell'})$.

\begin{remark}
    Sometimes, to simulate the ``interaction'' with the verifier, one uses the ``Fiat-Shamir Channel''. Its main purpose is to simulate the verifier's queries and random coins. For example, one might implement it as a class/struct with the following methods:
    \begin{enumerate}
        \item \texttt{send\_message($m$)}: ``sends'' the message $m$ to the verifier. Under the hood, the proof stream accumulates the current state $s$ and appends $m$ to it.
        \item \texttt{sample()}: returns the challenge $r$ from the random oracle $\mathcal{O}_{\text{R}}$, applied to the current state $s$.
        \item \texttt{get\_proof()}: returns the proof $\pi$, being the history of interaction, that the prover can publish.
    \end{enumerate}

    One can check the \href{https://github.com/facebook/winterfell/blob/main/prover/src/channel.rs}{\texttt{winterfell}} Rust library or a \href{https://github.com/actuallyachraf/zkstarks/blob/master/fs.go}{simpler non-production implementation} of the Fiat-Shamir Channel in Golang for more details.
\end{remark}

\begin{figure}[H]
    \centering
    \scalebox{0.92}{
    \begin{tikzpicture}
        % Blue zone
        \node[very thick, draw=blue, fill=blue, fill opacity=0.1,minimum width=7cm, minimum height=7cm,dashed,on background layer](targetbox) at (2.25,-5.0) {};
        \node(targetzonelabel)[left=0.6cm of targetbox,rotate=90,anchor=north,color=blue!90!black]{\textbf{Non-interactive part}};

        % Three participants
        \node[inner sep=0pt, align=center] (prover) {\includegraphics[width=1.25cm]{lectures/images/common/prover.png}\\Prover $\mathcal{P}$};
        \node[inner sep=0pt, align=center, right=1.5cm of prover] (hash) {\includegraphics[width=1.25cm]{lectures/images/common/random_oracle.png}\\Proof Stream\\ (with random oracle $\mathcal{O}_{\text{R}}$)};
        \node[inner sep=0pt, align=center, right=7.5cm of prover] (verifier) {\includegraphics[width=1.25cm]{lectures/images/common/verifier.png}\\Verifier $\mathcal{V}$};
        
        % Dashed lines under participants
        \draw [dashed,line width=0.3mm] ([yshift=-0.5cm]prover.south) -- ([yshift=-9.5cm]prover.south);
        \draw [dashed,line width=0.3mm] ([yshift=-0.5cm]hash.south) -- ([yshift=-9.5cm]hash.south);
        \draw [dashed,line width=0.3mm] ([yshift=-0.5cm]verifier.south) -- ([yshift=-9.5cm]verifier.south);

        % Prover + Proof Stream
        \draw[-{Stealth[length=3mm]},line width=0.4mm,color=blue!90!black] ([yshift=-1.5cm]prover.south) coordinate (l2)--(l2-|hash) node[midway, above=0mm,]{``Send'' $m_1$};
        \draw[-{Stealth[length=3mm]},line width=0.4mm,color=blue!90!black] ([yshift=-2.25cm]hash.south) coordinate (l2)--(l2-|prover) node[midway, above=0mm]{$r_1 \gets \mathcal{O}_{\text{R}}(x,m_1)$};
        \draw[-{Stealth[length=3mm]},line width=0.4mm,color=blue!90!black] ([yshift=-3.5cm]prover.south) coordinate (l2)--(l2-|hash) node[midway, above=0mm]{``Send'' $m_2$};
        \draw[-{Stealth[length=3mm]},line width=0.4mm,color=blue!90!black] ([yshift=-4.25cm]hash.south) coordinate (l2)--(l2-|prover) node[midway, above=0mm]{$r_2 \gets \mathcal{O}_{\text{R}}(x,m_1,m_2)$};
        \draw[-{Stealth[length=3mm]},line width=0.4mm,color=blue!90!black] ([yshift=-6cm]prover.south) coordinate (l2)--(l2-|hash) node[midway, above=0mm]{``Send'' $m_{\ell}$};
        \draw[-{Stealth[length=3mm]},line width=0.4mm,color=blue!90!black] ([yshift=-6.75cm]hash.south) coordinate (l2)--(l2-|prover) node[midway, above=1mm]{$r_{\ell} \gets \mathcal{O}_{\text{R}}(x,m_1,\dots,m_{\ell})$};
        
        % Sending proof
        \draw[-{Stealth[length=3mm]},line width=0.4mm,color=green!50!black] ([yshift=-8.5cm]prover.south) coordinate (l2)--(l2-|verifier) node[midway, above=0mm, fill=white]{Send $\pi = (m_1,r_1,m_2,r_2,\dots,m_{\ell},r_{\ell})$};

        \node[align=center,fill=white!5,thick,below=9cm of verifier](verifier-decision){
        \noindent\rule{3.5cm}{0.8pt}\\
        Verify $\pi$ \\
        \noindent\rule{3.5cm}{0.8pt}};
    \end{tikzpicture}
    }

    \caption{The non-interactive protocol between prover $\mathcal{P}$ and verifier $\mathcal{V}$ using Fiat-Shamir Transformation. In \textcolor{blue!90!black}{\textbf{blue}} we marked a non-interactive part of the protocol, being the ``communication'' between a prover and a proof stream. In \textcolor{green!50!black}{\textbf{green}} we marked the final proof $\pi$ that is sent to the verifier.}
    \label{fig:fiat-shamir}
\end{figure}

The process is illustrated in \Cref{fig:fiat-shamir}. The Fiat-Shamir looks as follows:
\begin{enumerate}
    \item First, the prover $\mathcal{P}$ ``sends'' the first message $m_1$ to the verifier $\mathcal{V}$. Here, ``sending'' is not an actual sending, but rather its simulation.
    \item If we had an interactive protocol, the verifier $\mathcal{V}$ would send the random challenge $r_1$ to the prover $\mathcal{P}$. Instead, we use the random oracle $\mathcal{O}_{\text{R}}$ to get $r_1 \gets \mathcal{O}_{\text{R}}(x,m_1)$.
    \item Then, using this challenge, prover does his part in the protocol, and sends the next message $m_2$. 
    \item Again, if we had an interactive protocol, the verifier would send the next challenge $r_2$ to the prover. Instead, we use the random oracle $\mathcal{O}_{\text{R}}$ to get $r_2 \gets \mathcal{O}_{\text{R}}(x,m_1,m_2)$, which gets ``sent'' to the prover.
    \item The process continues until the protocol is finished.
\end{enumerate}

Note that the whole process can be done by a prover with no interaction with the ``verifier''. In this case, one of the ways to represent the proof $\pi$ is to publish the transcript of the interaction (that is, all the messages sent by the prover and challenges computed using the random oracle). This is exactly what is done in STARKs.

The reason why such transformation works is that the random oracle $\mathcal{O}_{\text{R}}$ is a \textit{random} function. Therefore, the challenges $r_1,r_2,\dots$ are \textit{random} values, and the prover cannot predict them (for example, by fabricating messages to have some specific output). That being said, the following theorem holds (which, of course, we are not going to prove since the proof is complicated).

\begin{theorem}
    Suppose that $(\mathcal{P},\mathcal{V})$ is a public-coin interactive argument of knowledge for some language $\mathcal{L}_{\mathcal{R}}$ with a negligible soundness error. Then, the Fiat-Shamir transformation of $(\mathcal{P}^{\mathcal{O}_{\text{R}}},\mathcal{V}^{\mathcal{O}_{\text{R}}})$ is a non-interactive argument for $\mathcal{L}_{\mathcal{R}}$ with negligible soundness error in the random oracle model $\mathcal{O}_{\text{R}}$.
\end{theorem}

\subsection*{Acknowledgements}

The material of this section was greatly inspired by the
\href{https://rdi.berkeley.edu/zk-learning/}{``Zero Knowledge Proofs MOOC,
Spring 2023''} series of lectures, in particular by the first lecture by Shafi
Goldwasser, and
\href{https://www.cs.princeton.edu/courses/archive/fall07/cos433/lec15.pdf}{``Zero
Knowledge Proofs Lecture''} by Boaz Barak.

\subsection{Exercises}

\textbf{Exercise 1.} When dealing with RSA protocol, one frequently encounters the following relation where $e$ is a prime number and $n \in \mathbb{N}$:
\begin{equation*}
    \mathcal{R} = \left\{ (w, x) \in \mathbb{Z}_n^{\times} \times \mathbb{Z}_n^{\times}: w^e = x \right\}
\end{equation*}

Which of the following is the language $\mathcal{L}_{\mathcal{R}}$ that corresponds to the relation $\mathcal{R}$?
\begin{enumerate}[(A)]
    \item Integers from $\mathbb{Z}_n^{\times}$ which have a modular root of $e$-th degree.
    \item Integers from $\mathbb{Z}_n^{\times}$ which are divisible by $e$.
    \item Integers $x$ from $\mathbb{Z}_n^{\times}$ with properly defined expression $x^e$.
    \item Integers from $\mathbb{Z}_n^{\times}$ which are prime.
    \item Integers from $\mathbb{Z}_n^{\times}$ for which $e$ is a primitive root.
\end{enumerate}

\textbf{Exercise 2.} Suppose that for some interactive protocol $(\mathcal{P}, \mathcal{V})$ during one round, the probability that the verifier $\mathcal{V}$ accepts a false statement is $1/8$. How many rounds of interaction are needed to guarantee $120$ bits of security? Assume here that $n$ bits of security means that the probability of accepting a false statement is at most $2^{-n}$.
\begin{multicols}{5}    
    \begin{enumerate}[(A)]
        \item $30$.
        \item $40$.
        \item $60$.
        \item $90$.
        \item $120$.
    \end{enumerate}
\end{multicols}

\textbf{Exercise 3.} Recall that for relation $\mathcal{R} = \{(w,x) \in \mathbb{Z}_N^{\times} \times \mathbb{Z}_N^{\times}: x = w^2\}$ we defined the following interactive protocol $(\mathcal{P}, \mathcal{V})$ to prove that $x \in \mathcal{L}_{\mathcal{R}}$:
\begin{itemize}
    \item $\mathcal{P}$ samples $r \xleftarrow{R} \mathbb{Z}_N^{\times}$ and sends $a = r^2$ to $\mathcal{V}$.
    \item $\mathcal{V}$ sends a random bit $b \in \{0,1\}$ to $\mathcal{P}$.
    \item $\mathcal{P}$ sends $z = r \cdot w^b$ to $\mathcal{V}$.
    \item $\mathcal{V}$ accepts if $z^2 = a \cdot x^b$, otherwise it rejects.
\end{itemize}

Suppose we use the protocol $(\mathcal{P}, \mathcal{V}^*)$ where the ``broken'' verifier $\mathcal{V}^*$ always outputs $b=1$. Which of the following statements is true?
\begin{enumerate}[(A)]
    \item Both the soundness and completeness of the protocol are preserved.
    \item The soundness of the protocol is preserved, but the completeness is broken.
    \item The completeness of the protocol is preserved, but the soundness is broken.
    \item Both the soundness and completeness of the protocol are broken.
\end{enumerate}

\textbf{Exercise 4.} What is the difference between the cryptographic proof and the proof of knowledge?
\begin{enumerate}[(A)]
    \item Cryptographic proof is a proof of knowledge that is secure against malicious verifiers.
    \item Cryptographic proof is a proof of knowledge that is secure against malicious provers.
    \item Cryptographic proof merely states the correctness of a statement, while the proof of knowledge also guarantees that the prover knows the witness.
    \item While cryptographic proof states that witness exists for the given statement, the proof of knowledge makes sure to make this witness unknown to the verifier.
    \item Proof of knowledge does not require verifier to know the statement, while cryptographic proof does.
\end{enumerate}

\textbf{Exercise 5.} What is the purpose of introducing the extractor?
\begin{enumerate}[(A)]
    \item To introduce the algorithm that simulates the malicious verifier trying to extract the witness from the prover.
    \item To define what it means that the prover knows the witness.
    \item To give the verifier the ability to extract the witness from the prover during the interactive protocol.
    \item To define the security of the interactive protocol that uses a more powerful verifier that can extract additional information from the prover.
    \item To give prover more power to extract randomness generated by the verifier.
\end{enumerate}

\textbf{Exercise 6.} What it means that the interactive protocol $(\mathcal{P}, \mathcal{V})$ is a zero-knowledge?
\begin{enumerate}[(A)]
    \item The verifier $\mathcal{V}$ cannot know whether the given statement is true or false.
    \item The verifier $\mathcal{V}$ cannot know whether the prover $\mathcal{P}$ knows the witness.
    \item View of the prover $\mathcal{P}$ in the protocol is indistinguishable from the view of the verifier $\mathcal{V}$.
    \item Any view of any verifier $\mathcal{V}$ can be simulated using some polynomial-time algorithm, outputting computationally indistinguishable distribution from the given view.
    \item The prover $\mathcal{P}$ can convince the verifier $\mathcal{V}$ that the statement is true without knowing the witness.
 \end{enumerate}

\textbf{Hint:} View of the participant in the protocol consists of all data he has access to during the protocol execution. For example, verifier $\mathcal{V}$'s view consists of the messages he sends and receives, as well as the random coins he generates.

% \newpage
% \textbf{Exercise 7.} Which of the following is \textbf{not} true about the Fiat-Shamir heuristic?
% \begin{enumerate}[(A)]
%     \item If the public-coin protocol is sound, the Fiat-Shamir transformation preserves the soundness.
%     \item The Fiat-Shamir heuristic does not break the completeness of the public-coin protocol it is applied to.
%     \item Practically, it allows to convert any interactive protocol into a non-interactive one.
%     \item To make Fiat-Shamir transformation pratical, the function modelling the random oracle should be hard to invert.
%     \item It is reasonable to use SHA256 to model the random oracle in the Fiat-Shamir transformation.
% \end{enumerate}

\end{document}