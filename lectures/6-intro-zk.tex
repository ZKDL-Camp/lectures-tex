\documentclass[../lecture-notes.tex]{subfiles}

\begin{document}

\subsection{Motivation}

Finally, we came to the most interesting part of the course: zero-knowledge proofs. Before we start with SNARKs, 
STARKs, Bulletproofs, and other zero-knowledge proof systems, let us first define what the zero-knowledge is. But even before 
that, we need to introduce some formalities. For example, what are ``proof'', ``witness'', and ``statement'' --- terms that are so widely used in zero-knowledge proofs.

Let us describe the typical setup. We have two parties: \textbf{prover} $\mathcal{P}$ and a \textbf{verifier} $\mathcal{V}$. The prover wants to convince the verifier that some statement is true. Typically, the statement is not obvious (well, that is the reason for building proofs after all!) and therefore there might be some ``helper'' data, called \textbf{witness}, that helps the prover to prove the statement. The reasonable question is whether the prover can simply send witness to verifier and call it a day. Of course since you are here, reading this lecture, it is obvious that the answer is no. More specifically, by introducing zk-SNARKs, STARKs, and other proving systems, we will try to mitigate the following issues:
\begin{itemize}
    \item \textbf{Zero-knowledge:} The prover wants to convince the verifier that the statement is true without revealing the witness. 
    \item \textbf{Argument of knowledge:} Moreover, typically we want to make sure that the verifier, besides the statement correctness, ensures that the prover \textbf{knows} such a witness related to the statement.
    \item \textbf{Succinctness:} The proof should be short, ideally logarithmic in the size of the statement. This is crucial for practical applications, especially in the blockchain space where we cannot allow to publish long proofs on-chain.
\end{itemize}

\begin{example}
    Suppose, given a hash function\footnote{The notation $\{0,1\}^*$ means binary strings of arbitrary length} $H: \{0,1\}^* \to \{0,1\}^{\ell}$, the prover $\mathcal{P}$ wants to convince the verifier $\mathcal{V}$ that he knows the preimage $x \in \{0,1\}^*$ such that $H(x) = y$ for some given public value $y \in \{0,1\}^{\ell}$. The properties listed above are interpreted as follows:
    \begin{itemize}
        \item \textbf{Zero-knowledge:} The prover $\mathcal{P}$ does not want to reveal \textit{anything} about the pre-image $x$ to the verifier $\mathcal{V}$.
        \item \textbf{Argument of knowledge:} Given a string $y \in \{0,1\}^{\ell}$ it is not sufficient for a prover to merely state that $y$ has a pre-image. The prover $\mathcal{P}$ must demonstrate to a verifier $\mathcal{V}$ that he \textbf{knows} such a pre-image $x \in \{0,1\}^*$.
        \item \textbf{Succinctness:} If the hash function takes $n$ operations to compute, the proof should be \textbf{much} shorter than $n$ operations. State-of-art solutions can provide proofs that are $O(\log n)$ is size!
    \end{itemize}
\end{example}

\subsection{Relations and Languages}
Recall that \textbf{relation} $\mathcal{R}$ is just a subset of $\mathcal{X} \times \mathcal{Y}$ for two arbitrary sets $\mathcal{X}$ and $\mathcal{Y}$. Now, we are going to intrduce the notion of a \emph{language of true statements} based on $\mathcal{R}$.

\begin{definition}[Language of true statements]
    Let $\mathcal{R} \subseteq \mathcal{X} \times \mathcal{Y}$ be a relation. We say that a statement $x \in \mathcal{X}$ is a \textbf{true} statement if $(x,y) \in \mathcal{R}$ for some $y \in \mathcal{Y}$, otherwise the statement is called \textbf{false}. We define by $\mathcal{L}_{\mathcal{R}}$ (the language over relation $\mathcal{R}$) the set of all true statements, that is:
    \begin{equation*}
        \mathcal{L}_{\mathcal{R}} = \{ x \in \mathcal{X}: \exists y \in \mathcal{Y} \; \text{such that} \; (x,y) \in \mathcal{R} \}.
    \end{equation*}
\end{definition}

Now, what is the purpose of introducing relations and languages? The answer is simple: suppose we have a prover $\mathcal{P}$ and verifier $\mathcal{V}$. The prover wants to convince the verifier that a statement $x \in \mathcal{X}$ is true, that is $x \in \mathcal{L}_{\mathcal{R}}$. However, the verifier does not trust the prover and wants to be sure that the statement is indeed true. This is where the notion of a \emph{proof} comes into play. Moreover, typically while proving the statement, the prover does not want to reveal any information about the \emph{witness} $y \in \mathcal{Y}$. 

Further, we denote by $w \in \mathcal{W}$ the witness for the statement $x \in \mathcal{L}_{\mathcal{R}}$. Oftentimes, one might also encounter notation $\phi$ to denote the statement, but we will stick to $x$ for simplicity.

\begin{example}
    Suppose we want to prove the following claim: number $n \in \mathbb{N}$ is the product of two large prime numbers $(p,q) \in \mathbb{N} \times \mathbb{N}$. Here, the relation is the following:
    \begin{equation*}
        \mathcal{R} = \{ (n, p, q) \in \mathbb{N}^3: n = p \cdot q \; \text{where $p,q$ are primes} \}
    \end{equation*}

    In this particular case, the language of true statements is defined as 
    \begin{equation*}
        \mathcal{L}_{\mathcal{R}} = \{n \in \mathbb{N}: \exists p,q \; \text{are primes such that}\; n = pq\}
    \end{equation*}
    
    Therefore, our initial claim we want to prove is $n \in \mathcal{L}_{\mathcal{R}}$. The witness for this statement is the pair $(p,q)$, where $p$ and $q$ are prime numbers such that $n = p \cdot q$ and typically (but not always) we want to prove this without revealing our witness: $p$ and $q$. For example, one valid witness for $n = 15$ is $(3,5)$, while $n=16$ does not have any valid witness, so $16 \not\in \mathcal{L}_{\mathcal{R}}$.
\end{example}

\begin{example}
    Another example of claim we want to prove is the following: number $y \in \mathbb{Z}_N^*$ is a quadratic residue modulo $N$, meaning there exists some $x \in \mathbb{Z}_N^*$ such that $y \equiv x^2 \pmod{N}$. The relation in this case is:
    \begin{equation*}
        \mathcal{R} = \{ (x, y) \in (\mathbb{Z}_N^*)^2: y \equiv x^2 \pmod{N} \}
    \end{equation*}

    In this case, $\mathcal{L}_{\mathcal{R}} = \{y \in \mathbb{Z}_N^*: \exists x \in \mathbb{Z}_N^* \; \text{such that} \; y \equiv x^2 \pmod{N}\}$. Here, our \textit{square root of $y$ modulo $N$}, that is $x$, is the witness for the statement $y \in \mathcal{L}_{\mathcal{R}}$. For example, for $N=7$ we have $4 \in \mathcal{L}_{\mathcal{R}}$ since $5$ is a valid witness: $5^2 \equiv 4 \pmod{7}$, while $3 \not\in \mathcal{L}_{\mathcal{R}}$ since there is no valid witness for $3$.
\end{example}


However, we want to limit ourselves to languages that has reasonably efficient verifier (since otherwise the problem is not really practical and therefore of little interest to us). For that reason, we define the notion of a \emph{NP Language} and from now on, we will be working with such languages.

\begin{definition}[NP Language]
    A language $\mathcal{L}_{\mathcal{R}}$ belongs to the NP class if there exists a polynomial-time verifier $\mathcal{V}$ such that the following two properties hold:
    \begin{itemize}
        \item \textbf{Completeness:} If $x \in \mathcal{L}_{\mathcal{R}}$, then there is a witness $w \in \mathcal{W}$ such that $\mathcal{V}(x, w) = 1$ with $|w| = \mathsf{poly}(|x|)$. Essentially, it states that true claims have \textit{short}\footnote{``Short'' is a pretty relative term which would further differ based on the context. Here, we assume that the proof is ``short'' if it can be computed in polynomial time. However, in practice, we will want to make the proofs even shorter: see SNARKs and STARKs.} proofs.
        \item \textbf{Soundness:} If $x \not\in \mathcal{L}_{\mathcal{R}}$, then for any $w \in \mathcal{W}$ it holds that $\mathcal{V}(x, w) = 0$. Essentially, it states that false claims have no proofs.
    \end{itemize}
\end{definition}

However, this construction on its own is not helpful to us. In particular, without having any randomness and no interaction, building practical proving systems is very hard. Therefore, we need some more ingredients!

\subsection{Interactive Probabilistic Proofs}

As mentioned above, we will bring two more ingredients to the table: \textbf{randomness} and \textbf{interaction}:
\begin{itemize}
    \item \textbf{Interaction:} rather than simply passively receiving the proof, the verifier $\mathcal{V}$ can interact with the prover $\mathcal{P}$ by sending challenges and receiving responses.
    \item \textbf{Randomness:} verifier can send random coins (challenges) to the prover, which the prover can use to generate responses.
\end{itemize}

\begin{remark}
    For those who have already worked with SNARKs, the above introduction might seem very confusing. After all, what we are aiming for is to build \textbf{non-interactive} zero-knowledge proofs. However, as it turns out, there are a plenty of ways to make \textit{some} interactive proofs non-interactive. We will discuss this in more detail later.
\end{remark}

Now, one of the drastic changes is the following: if $x \not\in \mathcal{L}_{\mathcal{R}}$, then the verifier $\mathcal{V}$ should reject the claim with overwhelming\footnote{Some technicality: as you know from the Lecture 2, the value $\varepsilon = \mathsf{negl}(\lambda)$ is called negligible since it is very close to $0$. In turn, the value $1-\varepsilon$ is called \textit{overwhelming} since it is close to $1$.} probability (in contrast to strict probability of $1$). Let us consider the concrete example.

\subsubsection{Example: Quadratic Residue Test}

Again, suppose for relation $\mathcal{R} = \{(x,y) \in (\mathbb{Z}_N^*)^2: y \equiv x^2 \pmod{n}\}$ and corresponding language $\mathcal{L}_{\mathcal{R}} = \{y \in \mathbb{Z}_N^*: \exists x \in \mathbb{Z}_N^* \; \text{such that} \; y \equiv x^2 \pmod{n}\}$ the prover $\mathcal{P}$ wants to convince the verifier that the given $y$ is in language $\mathcal{L}_{\mathcal{R}}$. Again, sending $x$ is not an option, as we want to avoid revealing the witness. So how can we proceed? The idea is that the prover $\mathcal{P}$ should prove that he \textit{could} prove it if he felt like it. 

So here how it goes. The prover $\mathcal{P}$ can first sample a random $r \xleftarrow{R} \mathbb{Z}_N^*$, calculate $s \gets r^2 \pmod{n}$ and say to the verifier $\mathcal{V}$: 
\begin{itemize}
    \item Hey, I could give you the square roots of both $s$ and $sy$ and that would convince you that the statement is true! But in this case, you would know $x$\footnote{If verifier gets both $r$ and $rx$, he can divide the latter by former and get $x$}.
    \item So instead of providing both values simultaneously, you will choose which one you want to see: either $r$ or $ry$. This way, after a couple of such rounds, you will not learn $x$ but you will be convinced that I know it.
\end{itemize}

That being said, formally the interaction between prover $\mathcal{P}$ and verifier $\mathcal{V}$ can be described as follows:
\begin{enumerate}
    \item $\mathcal{P}$ samples $r \xleftarrow{R} \mathbb{Z}_N^*$ and sends $s \gets r^2 \pmod{n}$ to $\mathcal{V}$.
    \item $\mathcal{V}$ sends a random bit $b \xleftarrow{R} \{0,1\}$ to $\mathcal{P}$.
    \item If $b=1$, the prover sends $z \gets r$, otherwise, if $b=0$, he sends $z \gets rx \pmod{n}$.
    \item The verifier checks whether $z^2 \equiv sy^{1-b} \pmod{n}$.
    \item Repeat the process for $\lambda \in \mathbb{N}$ rounds.
\end{enumerate}

\begin{figure}
    \centering
    \begin{tikzpicture}
        \node[inner sep=0pt, align=center] (prover) {\includegraphics[width=1.25cm]{lectures/images/lecture_6/prover.png}\\Prover $\mathcal{P}$};
        \node[inner sep=0pt, align=center, right=5cm of prover] (verifier) {\includegraphics[width=1.25cm]{lectures/images/lecture_6/verifier.png}\\Verifier $\mathcal{V}$};

        \draw [dashed,line width=0.3mm] ([yshift=-0.5cm]prover.south) -- ([yshift=-11cm]prover.south);
        \draw [dashed,line width=0.3mm] ([yshift=-0.5cm]verifier.south) -- ([yshift=-11cm]verifier.south);

        \node[align=center,fill=white!5,thick,below=0.5cm of prover](prover-setup){
        \noindent\rule{3.5cm}{0.8pt}\\
        $r \xleftarrow{R} \mathbb{Z}_N^*$ \\
        $s \gets r^2 \pmod{N}$ \\
        \noindent\rule{3.5cm}{0.8pt}};

        \draw[-{Stealth[length=3mm]},line width=0.4mm] ([yshift=-3.25cm]prover.south) coordinate (l2)--(l2-|verifier) node[midway, above=2mm, fill=white]{Send $s$};

        \node[align=center,fill=white!5,thick,below=4cm of verifier](verifier-choice){
        \noindent\rule{3.5cm}{0.8pt}\\
        I am choosing a bit! \\
        $b \xleftarrow{R} \{0,1\}$ \\
        \noindent\rule{3.5cm}{0.8pt}};

        \draw[-{Stealth[length=3mm]},line width=0.4mm] ([yshift=-6.5cm]verifier.south) coordinate (l2)--(l2-|prover) node[midway, above=2mm, fill=white]{Send $b$};

        \node[align=center,fill=white!5,thick,below=7.5cm of prover](prover-setup){
        \noindent\rule{3.5cm}{0.8pt}\\
        If $b=1$, send $z \gets r$ \\
        If $b=0$, send $z \gets xr \pmod{N}$ \\
        \noindent\rule{3.5cm}{0.8pt}};

        \draw[-{Stealth[length=3mm]},line width=0.4mm] ([yshift=-10cm]prover.south) coordinate (l2)--(l2-|verifier) node[midway, above=2mm, fill=white]{Send $z$};

        \node[align=center,fill=white!5,thick,below=10.5cm of verifier](verifier-choice){
        \noindent\rule{3.5cm}{0.8pt}\\
        Verify $z^2 \equiv sy^{1-b} \pmod{N}$ \\
        \noindent\rule{3.5cm}{0.8pt}};
    \end{tikzpicture}

    \caption{The interactive protocol between prover $\mathcal{P}$ and verifier $\mathcal{V}$ for the quadratic residue test.}
\end{figure}

Now, let us show that the provided protocol is indeed \textbf{complete} and \textbf{sound}.

\textbf{Completeness.} Suppose the verifier chose $b=1$ and thus the prover sent $r$. The check would be $r^2 \equiv sy^{1-1} \pmod{N}$ which is equivalent to $r^2 \equiv s \pmod{N}$. This obviously holds. 

If, in turn, the verifier chose $b=0$ and the prover sent $rx$, the check would be $(rx)^2 \equiv sy^{1-0} \pmod{N}$ which is equivalent to $r^2x^2 \equiv sy \pmod{N}$. Since $s = r^2 \pmod{N}$ and $y = x^2 \pmod{N}$, this check also obviously holds.

\textbf{Soundness.} Here, we need to prove that for any dishonest prover who does not know $x$, the verifier will reject the claim with overwhelming probability. One can show the following fact.

\begin{proposition}
    If $y \not\in \mathcal{L}_{\mathcal{R}}$, then for any prover $\mathcal{P}$, the verifier $\mathcal{V}$ will reject the claim with probability at least $1/2$.
\end{proposition}

By making $\lambda$ rounds, the probability of rejection is $\left(\frac{1}{2}\right)^{\lambda} = \mathsf{negl}(\lambda)$ and therefore the verifier can be convinced that $y \in \mathcal{L}_{\mathcal{R}}$ with overwhelming probability of $1-2^{-\lambda}$.

To denote the interaction between algorithms $\mathcal{P}$ and $\mathcal{V}$ on the statement $x$, we use notation $\langle \mathcal{P}, \mathcal{V} \rangle(x)$. Finally, now we are ready to define the notion of an \textbf{interactive proof system}.

\begin{definition}
    A pair of algorithms $(\mathcal{P},\mathcal{V})$ is called an \textbf{interactive proof} for a language $\mathcal{L}_{\mathcal{R}}$ if $\mathcal{V}$ is a polynomial-time verifier and the following two properties hold:
    \begin{itemize}
        \item \textbf{Completeness:} For any $x \in \mathcal{L}_{\mathcal{R}}$, $\text{Pr}[\langle \mathcal{P}, \mathcal{V} \rangle(x) = \mathsf{accept}]=1$.
        \item \textbf{Soundness:} For any $x \not\in \mathcal{L}_{\mathcal{R}}$ and for any prover $\mathcal{P}^*$, we have 
        \begin{equation*}
            \text{Pr}[\langle \mathcal{P}^*, \mathcal{V} \rangle(x) = \mathsf{accept}] \leq \mathsf{negl}(\lambda)
        \end{equation*}
    \end{itemize}
\end{definition}

\begin{definition}
    Besides classes \textbf{P} and \textbf{NP}, we now have one more class: \textbf{the class of interactive proofs} (\textbf{IP}):
    \begin{equation*}
        \mathbf{IP} = \{\mathcal{L}: \text{there is an interactive proof $(\mathcal{P}, \mathcal{V})$ for $\mathcal{L}$}\}.
    \end{equation*}
\end{definition}

\subsection{Schnorr's Identification Protocol}

One very useful protocol for demonstration purposes is Schnorr's identification protocol. It is a simple and elegant protocol that allows one party to prove to another party that it knows a discrete logarithm of a given element. 

Suppose $\mathbb{G}$ is a cyclic group of prime order $q$ with generator $g \in \mathbb{G}$. Suppose prover $\mathcal{P}$ has a secret key $\alpha \in \mathbb{Z}_q$ and the corresponding public key $u = g^{\alpha} \in \mathbb{G}$ and he wants to convince the verifier $\mathcal{V}$ that he knows $\alpha$ corresponding to the public key $u$. 

Well, the easiest way how to proceed is simply giving $\alpha$ to $\mathcal{V}$, but this is obviously not what we want. Instead, the Schnorr protocol allows $\mathcal{P}$ to prove the knowledge of $\alpha$ without revealing it. 

Let us finally describe the protocol. The schnorr identification protocol $\Pi_{\text{Schnorr}} = (\mathsf{Gen}, \mathcal{P}, \mathcal{V})$ with a generation function $\mathsf{Gen}$ and prover $\mathcal{P}$ and verifier $\mathcal{V}$ is defined as follows:
\begin{itemize}
    \item $\mathsf{Gen}(1^{\lambda})$: As with most public-key cryptosystems, we take $\alpha \xleftarrow{R} \mathbb{Z}_q$ and $u \gets g^{\alpha}$. We output the \textit{verification key} as $\mathsf{vk} := u$, and the \textit{secret key} as $\mathsf{sk} := \alpha$.
    \item The protocol between $(\mathcal{P},\mathcal{V})$ is run as follows:
    \begin{itemize}
        \item $\mathcal{P}$ computes $\alpha_T \gets \mathbb{Z}_q, u_T \gets g^{\alpha_T}$ and sends $u_T$ to $\mathcal{V}$.
        \item $\mathcal{V}$ sends a random challenge $c \xleftarrow{R} \mathbb{Z}_q$ to $\mathcal{P}$.
        \item $\mathcal{P}$ computes $\alpha_C \gets \alpha_T + \alpha c \in \mathbb{Z}_q$ and sends $\alpha_C$ to $\mathcal{V}$.
        \item $\mathcal{V}$ accepts if $g^{\alpha_C} = u_T \cdot u^c$, otherwise it rejects.
    \end{itemize}
\end{itemize}

\end{document}