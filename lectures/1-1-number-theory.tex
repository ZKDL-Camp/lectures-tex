\documentclass[../lecture-notes-148x210.tex]{subfiles}

\begin{document}
    
As mentioned earlier, the cryptography must work with integer-based formats. 
One of the earliest and most fundamental branches of mathematics is number theory, which 
deals with the properties of the integer set $\mathbb{Z}$. Although, as we will see later, 
we will primarily need the notion of \emph{prime/finite field} further, the basic concepts 
of number theory will still be used extensively nonetheless.

\subsection{Introduction to number theory}

We start with the most basic definition of number theory --- \emph{divisibility}.

\begin{definition}
    An integer $a$ is divisible by a non-zero integer $b$, denoted $b \mid a$ (or \emph{b is a divisor of a}), if and only if there exists an integer $k \in \mathbb{Z}$ such that $a = k \cdot b$.
\end{definition}

Let us consider some basic properties of this relation.

\begin{lemma}[Divisibility properties]
    For all $a, b, c \in \mathbb{Z}:$
    \hfill
    \begin{enumerate}
        \item $1 \mid a$ (any number is divisible by $1$)
        \item If $a \neq 0$, then $a \mid a$ (any non-zero integer divides itself).
        \item If $a \neq 0$, then $a \mid 0$ (any non-zero integer divides $0$).
        \item If $b \mid a$ and $c \mid b$, then $c \mid a$ (formally called \emph{transitivity}).
        \item $b \mid a \iff b \cdot c \mid a \cdot c$ for any $c \neq 0$.
        \item If $c \mid a$ and $c \mid b$, then $c \mid (\alpha \cdot a \pm \beta \cdot b)$, $\text{for any } \alpha, \beta \in \mathbb{Z}$
    \end{enumerate}
\end{lemma}

But what happens if a number $a$ is not divisible by the given integer $b$, meaning there is no integer $k$ that satisfies the condition $a = b \cdot k$? In such cases, a new theorem comes into play.

\begin{theorem}[Division theorem]\label{th:division}
    \begin{equation*}
        \forall a, b \in \mathbb{Z} \; \exists! q, r \in \mathbb{Z} \; \text{such that} \; a = b \cdot q + r \; \text{with} \; 0 \leq r < |b|
    \end{equation*}
\end{theorem}

To prove this theorem, all we need to prove is the existence and uniqueness of
such a decomposition. To not make the book too long, we will not prove this
theorem here, but you can find the proof in any number theory textbook.

This theorem allows us to define two new operations. Suppose $a,b,q,r$ are given
as in the \Cref{th:division}. Then,
\begin{itemize}
    \item \textbf{Floor Operation} ($\lfloor a/b \rfloor$ or $a \; \text{div} \;
b$) is defined as $q$. This operation is a standard \texttt{div} opeartion
commonly used in programming languages.
    \item \textbf{Mod Operation} ($a \; \text{mod} \; b$) is defined as $r$. This operation is a standard
\texttt{mod} operation commonly used in programming languages. 
\end{itemize}

In division operations, it is common to check for any shared factors between two
numbers. This is where the concept of the \textbf{greatest common divisor} (or
\textbf{gcd} for short) comes into play.

\begin{definition}[GCD]
    For any $a, b \in \mathbb{Z}$, the \textbf{greatest common divisor} $\gcd(a, b)$ is defined as an integer $d \in \mathbb{N}$ such that:
    \begin{enumerate}
        \item $d \mid a$ and $d \mid b$.
        \item $d$ is a maximal integer that satisfies the first condition.
    \end{enumerate}

    One might right the above definition more concisely:
    \begin{equation*}
        \gcd(a,b) = \max\{d \in \mathbb{N}: d \mid a \; \text{and} \; d \mid b\}.
    \end{equation*}
\end{definition}

\begin{definition}
    Two numbers $a$ and $b$ are \textbf{coprime} if and only if $\gcd(a, b)~=~1$.
\end{definition}

As with any previous concept, let us check some basic properties of the GCD operation.

\begin{lemma} [Greatest common divisor properties]
    \hfil
    \begin{enumerate}
        \item $\gcd(a, b) = b \iff b \mid a$
        \item If $a \neq 0$, then $\gcd(a, 0) = a$
        \item If there exists $\delta \in \mathbb{Z}$ such that $\delta \mid a$ and $\delta \mid b$, then $\delta \mid \gcd(a, b)$
        \item If $c > 0$, then $\gcd(ac, bc) = c \cdot \gcd(a, b)$
        \item Suppose $d = \gcd(a, b)$. Then, $\gcd(a/d, b/d) = 1$
    \end{enumerate}
\end{lemma}

\begin{lemma}
    For any $a,b \in \mathbb{Z}$, we have $\gcd(a, b) = \gcd(b, a - b)$. 
\end{lemma}

The aforementioned lemma will be further extensively used for the Euclidean algorithm.

\begin{corollary}\label{cor:euclidean}
    As a corollary, for any $a,b \in \mathbb{Z}$ we also have 
    $\gcd(a,~b)~=~\gcd(b,~a~\,~\text{mod}~\,~b)$.
\end{corollary}

All these properties are interesting and useful from the theory standpoint, but
you may wonder how to practically find $\gcd(a, b)$ (say, if you were to
implement this function in the programming language). \emph{Euclidean algorithm} is an
efficient method for computing the greatest common divisor. The main idea of 
Euclidean algorithm is to recursively apply the \Cref{cor:euclidean}. The concrete implementation 
in Python is specified below. 
\begin{lstlisting}[language=Python, numbers=none]
def gcd(a: int, b: int) -> int:
    return gcd(b, a % b) if b != 0 else a
\end{lstlisting}

Notice that the algorithm can be easily implemented in a single line.

While the greatest common divisor (gcd) focuses on finding the largest shared factor between two numbers, the least common multiple (lcm) deals with finding the smallest multiple that both numbers have in common. The LCM is particularly useful when we need to synchronize cycles or work with fractions.

\begin{definition}[LCM]
    For any $a, b \in \mathbb{Z}$, the \textbf{least common multiple} $\lcm(a,
    b)$ is defined as an integer $m \in \mathbb{N}$ such that:
    \begin{enumerate}
        \item $a \mid m$ and $b \mid m$
        \item $m$ is a minimal integer that satisfies the first condition 
    \end{enumerate}

    One might right the above definition more concisely:
    \begin{equation*}
        \lcm(a,b) = \min\{m \in \mathbb{N}: a \mid m \; \text{and} \; b \mid m\}.
    \end{equation*}
\end{definition}

\begin{lemma} [Least Common Multiple Properties]
    \hfil
    \begin{enumerate}
        \item We assume that $\lcm(a, 0)$ is undefined.
        \item $\lcm(a, b) = a \iff b \mid a$.
        \item If $a$ and $b$ are coprime, then $\lcm(a, b) = a \cdot b$.
        \item Any common divisor $\delta$ of $a$ and $b$ satisfies $\delta \mid \lcm(a, b)$.
        \item For any $c > 0$, we have $\lcm(a \cdot c, b \cdot b) =  c \cdot \lcm(a, b)$.
        \item Integers $\lcm(a, b)/a$ and $\lcm(a, b) / b$ are coprime.
    \end{enumerate}
\end{lemma}

\begin{theorem}
    For any $a, b \in \mathbb{N}$, we have $\gcd(a, b) \cdot \lcm(a, b) = ab$.
\end{theorem}

One interpretation of the above theorem is that no additional algorithm is required for
$\text{lcm}(a, b)$ if we already have an algorithm for $\gcd(a, b)$. Indeed, we
can simply use the formula $\text{lcm}(a, b) = ab / \gcd(a, b)$ with the
previously computed $\gcd(a, b)$.

The reasonable question is how to generalize the $\gcd$ and $\lcm$ operations to more than two arguments. 
For that reason, we provide the following algorithm:
\begin{definition}[GCD and LCM for multiple arguments]
    We define the \textbf{greatest common divisor} $\gcd(a_1, a_2, \dots, a_n)$ and the \textbf{least common multiple} $\lcm(a_1, a_2, \dots, a_n)$ for any set of integers $a_1, a_2, \dots, a_n \in \mathbb{Z}$ as follows:
    \begin{align*}
        \gcd(a_1, a_2, \dots, a_n) &= \max\{ d \in \mathbb{N}: d \mid a_1, d \mid a_2, \dots, d \mid a_n \}. \\
        \lcm(a_1, a_2, \dots, a_n) &= \min\{ m \in \mathbb{N}: a_1 \mid m, a_2 \mid m, \dots, a_n \mid m \}.
    \end{align*}
\end{definition}

\begin{theorem}[Computational Properties Of GCD and LCM For Multiple Arguments.]
    The following two statements are true:
    \begin{itemize}
        \item $\forall a, b \in \mathbb{N}: \gcd(a, b, c) = \gcd(\gcd(a, b), c) = \gcd(a, \gcd(a, b))$.
        \item $\forall a, b \in \mathbb{N}: \lcm(a, b, c) = \lcm(\lcm(a, b), c) = \lcm(a, \lcm(a, b))$.
    \end{itemize}
\end{theorem}

In conclusion, from these two theorems there is no necessity for specific
algorithms for $\gcd$ and $\lcm$ when dealing with many arguments. There are
more specialized algorithms for each when considering a specific number of
arguments, but unfortunately, such topics are beyond the scope of this book.

\subsection{Extended Euclidean algorithm}

In this section, we will introduce the Extended Euclidean Algorithm and an
important lemma related to the GCD. You might have reasonable question: why do
we even need an extended version? One of the primary reasons is that this 
algorithm will help in finding inverse modular elements, introduced in the 
subsequent sections.

\begin{lemma} [Bezout identity] \label{lemma:bezout_identity}
    For any two given integers $a, b \in \mathbb{N}$ with $d = \gcd(a, b)$ there exists such $u, v \in \mathbb{Z}$ that $d = au + bv$.
\end{lemma}

\begin{corollary} [From Bezout identity]
    \hfill
    \begin{enumerate}
        \item Integers $u$ and $v$ are of different signs (excluding the case when either $u=0$ or $v=0$).
        \item \textit{Generalization for multiple integers:} Suppose $d = \gcd(a_1, a_2, \dots, a_n)$, then there exist such integers $u_1, u_2, \dots, u_n \in \mathbb{Z}$ that $d = u_1 a_1 + u_2 a_2 + \cdots + u_n a_n$.
    \end{enumerate}    
\end{corollary}

The integers $u$ and $v$ are called \textbf{Bezout coefficients}. The first
corollary can be understood intuitively: if all coefficients are non-negative,
the result will be much larger than necessary. Similarly, if they are
non-positive, the result must be negative, but the GCD was defined to be
positive. The second consequence follows from the fact that we can decompose
gcd, thus sequentially derive this sequence. Also note that we can find Bezout
coefficients on each Euclidean algorithm step.

Now we introduce the \textbf{extended Euclidean algorithm.} The extended
Euclidean algorithm finds the Bezout coefficients together with the GCD
efficiently.

\begin{algorithm}[H]
    \caption{Extended Euclidean algorithm} \label{alg:extended_euclidean}
    \Input{$a, b \in \mathbb{N}$. Without loss of generality, $a \geq b$}
    \Output{$(\gcd(a, b), u, v)$}
        
    $r_{0} \gets a; \, r_{1} \gets b$ \\
    $u_{0} \gets 1; \, u_{1} \gets 0$ \\
    $v_{0} \gets 0; \, v_{1} \gets 1$ \\

    \While{$r_{i+1} \neq 0, \; i = 1, 2, \dots$}{
        $q_i \gets  r_{i-1} \; \text{div} \; r_{i}$ \\
        $u_{i+1} \gets u_{i-1} - u_{i} q_i$ \\
        $v_{i+1} \gets v_{i-1} - v_{i} q_i$ \\
        $r_{i+1} \gets  a u_{i+1} + b v_{i}$ \\
    }

    \textbf{return} $(r_i, u_i, v_i)$
\end{algorithm}

The time complexity of the Extended Euclidean algorithm is $O(\log{a} \log{b})$ bit
operations, which is very efficient. Although we already know how the
Extended Euclidean Algorithm works, this method is still not very
human-friendly. For that reason, let us consider an example of an easy way to
find the GCD.

\begin{example} [Extended Euclidean algorithm example]
    \hfill

    First, we you need to find $d = \gcd(a,b)$. Then, knowing the sequence of
    expansions, find the Bezout coefficients. Note that this can be done
    simultaneously.

    \hfill

    \begin{minipage}{0.4\textwidth}
        \raggedright
        \vspace*{\fill}
            \begin{enumerate}
                \item $125 = 93 \cdot 1 + 32$
                \item $93 = 32 \cdot 2 + 29$
                \item $32 = 29 \cdot 1 + 3$
                \item $29 = 3 \cdot 9 + 2$
                \item $3 = 2 \cdot 1 + 1$
                \item $2 = 1 \cdot 2 + 0$        
            \end{enumerate}
        \vspace*{\fill}
    \end{minipage}
    \begin{minipage}{0.7\textwidth}
        \resizebox{0.7\textwidth}{!}{
            \begin{tabular}{|c|c|c|c|c|c|c|c|}
                \hline
                
                \rowcolor{gray!30} $i$   & $0$      & $1$ & $2$ & $3$ & $4$ & $5$ & $6$ \\
                
                \hline
                \hline

                $q_i$ & $\times$ & $1$ & $2$ & $1$ & $9$ & $1$ & $2$ \\
                
                \hline
                
                $u_i$ & $1$      & $0$ & $1$ & $-2$ & $3$ & $-29$ & $32$ \\
                \hline
                $v_i$ & $0$      & $1$ & $-1$ & $3$ & $-4$ & \textcolor{green!60!black}{\textbf{?}} & \textcolor{green!60!black}{\textbf{?}} \\
                
                \hline
            \end{tabular}
        }
    \end{minipage}

    \hfill
    
    Here, each corresponding cell is calculated with the following formula: 
    \begin{align*}
        u_{i-1} - q_i u_i &= u_{i+1} \\
        v_{i-1} - q_i v_i &= v_{i+1} 
    \end{align*}
    Knowing that, try to finish this example by filling in the missed cells
    marked by \textcolor{green!60!black}{\textbf{?}}. After finding $v_6$, be
    sure to check yourself.
\end{example}

\subsection{Prime numbers}

Prime numbers are fundamental in mathematics due to their role of the building
blocks of all natural numbers. Every integer greater than 1 can be uniquely
factored into primes, a concept known as the \emph{Fundamental Theorem of
Arithmetic}, which we introduce in the next section. This property makes primes
central to number theory, and they play a crucial role in various mathematical
proofs and structures.

\begin{definition}
    Number $n \in \mathbb{N}$ is \textbf{prime} if and only if its only two divisors are $1$
    and $n$. 
\end{definition}

\begin{definition}
    Number $n \in \mathbb{N}$ is \textbf{composite} iff there exists an integer
    $a \in \mathbb{N}$, which is not $1$ or $n$, for which $a \mid n$. In other words,
    it is not prime.
\end{definition}

\begin{remark}
    One might ask: what to do with the number $1$? We consider it to
    be neither prime nor composite.
\end{remark}

\begin{lemma}
    For all $n \in \mathbb{N}$, we have $\gcd(n, n+1) = 1$
\end{lemma}

\begin{theorem} [Euclidean theorem]
    If $P = \{p_1, p_2, p_3, \dots p_k\} \subset \mathbb{N}$ is a finite set,
    consisting of prime numbers, then there exists a prime number $p$ such that
    $p \notin P$.
\end{theorem}

\begin{corollary}
    The set of prime numbers has an infinite cardinality.
\end{corollary}

\begin{lemma}
    For all $n \in \mathbb{N}$, where $n$ is composite, if there exists a 
    minimal divisor $d>1$ of $n$, then $d$ is a prime number.
\end{lemma}

Let's say we have a large number and we need to find out if it is prime, how do we do it?
In other words, are there any methods for checking a number for prime?
Yes, there are, starting with logical reasoning, you can check numbers with brute force, although
this method is not practically applicable. There are probabilistic prime tests that will fail
with some error. In 2003, an effective deterministic test of simplicity was found, which moved
the problem to the class $P$.

It is worth to be mentioned, there are also different forms of primes that find their application in some fields. 
For example, Mersenne primes, factorial primes, Euclidean primes, Fibonacci primes, and many other types of primes.
We will consider one of the most famous types of primes --- Mersenne primes.

\begin{definition} [Mersenne primes]
    The prime number of form $2^p - 1$ is called \textbf{Mersenne prime}, where $p$ is a
    prime number.
\end{definition}

Mersenne primes, are important in both number theory and cryptography.
They have unique mathematical properties that make them useful for testing primality and generating large prime numbers.
Mersenne primes are also crucial in the construction of efficient algorithms for error correction in coding theory and for generating random numbers in cryptographic applications, etc. 
Beside, next theorem importan says that we can know the form of a prime numbers.

\begin{theorem} [Dirichlet's theorem]
    For any $a, b \in \mathbb{N}$ if $\gcd(a, b) = 1$, then infinite primes number form of $am + b$ exists, where $m \in \mathbb{N}$.
\end{theorem}

In other words, every infinite arithmetic progression whose first term and difference are positive integers contains an infinite number of primes.

\subsection{Fundamental Theorem of Arithmetic}
The Fundamental Theorem of Arithmetic states that every integer greater than 1 can be uniquely factored into primes, which is crucial for understanding the structure of numbers. 
It plays a key role in areas like number theory, cryptography, and simplifying calculations involving divisibility. 
But before formal description of the theorem, for better understanding it is good to know the following Lemma \ref{euclidean_lemma}.

\begin{lemma}[Euclidean] \label{euclidean_lemma}
    If $p$ is a prime and $p \mid ab$, then $p \mid a$ or $p \mid b$.
\end{lemma}

\textbf{Proof.} 
$\blacktriangleright$
Let $p \mid ab$, but $ p \nmid a$, then $\gcd(a, p) = 1$ because there are no common divisors.
In which case, by Bezout identity \Cref{lemma:bezout_identity}, there exist such $u, v \in \mathbb{Z}$ that $au + pv = 1$.
Let's multiply the left and right sides by $b$: $abu + pbv = b$, but $p \mid ab$ and $p \mid pb$, therefore their sum is also divisible by $p \mid abu + pbv$. 
$\blacktriangleleft$

Now, we are ready to introduce the central Number Theory theorem --- Fundamental
Theorem of Arithmetic.

\begin{theorem}[Fundamental theorem of arithmetic]\label{th:fundamental_arithmetic}
    Any integer $n>1$ can be decomposed in the unique way into a product of prime numbers:
    \begin{equation*}
        n = p_1^{\alpha_1}p_2^{\alpha_2}\cdots p_t^{\alpha_t} = \prod_{j=1}^t p_j^{\alpha_j},
    \end{equation*}
    where $p_1,\dots,p_t$ are prime numbers and $\alpha_1,\dots,\alpha_t \in \mathbb{N}$.
\end{theorem}

\textbf{Proof.} 
$\blacktriangleright$  
The theorem state equation then need to proof equation existence and uniqueness. Since the existence property is 
easy to prove, let us make the small exception and show it. For other proves (in particular, for the uniqueness case, see literature)

\textcolor{green!60!black}{\textbf{Existence}}. Suppose the theorem statement is false and there exist $n$ that do not have such a representation.
Let $n_0$ be the smallest of them.
If $n_0$ is prime, it can be represented as $p_1=n_0$, $\alpha_1=1$, which satisfies the representation. Therefore, $n_0$ must be composite, which means $\exists a, b \in \mathbb{N}, 1 < a, b < n_0$ such that $n = ab$.
Since $n_0$ is the smallest non-decomposable number and $a, b < n_0$, then $a$ and $b$ can be represented as 
\begin{align*}
    a &= p_{1}^{\alpha_{1}} \dots p_{t}^{\alpha_{t}} \\
    b &= q_{1}^{\beta_{1}} \dots q_{k}^{\beta_{k}}.
\end{align*}
Therefore, $n_0 = ab=p_{1}^{\alpha_{1}} \dots p_{t}^{\alpha_{t}} q_{1}^{\beta_{1}} \dots q_{k}^{\beta_{k}}$. Thus, the contradiction. $\blacktriangleleft$  

\begin{corollary}
    Suppose $n$ is decomposed as in \Cref{th:fundamental_arithmetic}. Then,

    \begin{enumerate}
        \item If $d \mid n$, then $d = p_{1}^{\beta_1}p_{2}^{\beta_2} \dots p_{t}^{\beta_t}$, where $0 \leq \beta_i \leq \alpha_i$.
        \item Suppose $a = p_{1}^{\alpha_1} \dots p_{t}^{\alpha_t}$ and $b = p_{1}^{\beta_1} \dots p_{t}^{\beta_t}$. Then, the GCD can be evaluated as $\gcd(a, b) = \prod_{i=0}^{t}p^{\min\{\alpha_i, \beta_i\}}$.
        \item Suppose $a = p_{1}^{\alpha_1} \dots p_{t}^{\alpha_t}$ and $b = p_{1}^{\beta_1} \dots p_{t}^{\beta_t}$. Then, the LCM can be evaluated as $\lcm(a, b) = \prod_{i=0}^{t}p^{\max\{\alpha_i, \beta_i\}}$.
        \item If $b \mid a$ and $c \mid a$ and $\gcd(b, c) = 1$, then $bc \mid a$.
    \end{enumerate}
\end{corollary}

The implications and applications of the Fundamental Theorem of Arithmetic are very large and important, and a number of “obvious” ones are listed above.
However, you should also be aware that the problem of factorization, i.e., knowing the decomposition of a number into prime factors, is in a NP class (complexity) and is the basis of some cryptosystems, although it is gradually being abandoned, including due to the potential of quantum computers.

\subsection{Modular arithmetic}

Now we are ready for practical applications of number theory, starting with modulo congruence.
In this section, we will review the idea of congruence, learn how to use it, and explore
its key properties. Understanding these properties will help simplify calculations and solve 
problems more efficiently in fields such as cryptography, algorithms, and number theory.

\begin{definition}
    Two integers $a, b \in \mathbb{Z}$ are said to be \textbf{congruent} modulo $n \in \mathbb{N}$ (congruence modulo $n$ is denoted as $a \equiv b \pmod{n}$), if one of the following conditions is met:
    \begin{enumerate}
        \item There exists such $t \in \mathbb{Z}$ that $a = b + nt$
        \item $a \; \texttt{mod} \; n = b \; \texttt{mod} \; n$
        \item $n \mid (a - b)$
    \end{enumerate}
\end{definition}

It is fairly easy to see that all conditions are equivalent to each other. Next, as always, it is necessary to formally describe the properties, although some of them may seem intuitive, they need to be formally defined.

\begin{lemma}[Reflexivity, Symmetry, and Transitivity] 
    \hfill
    \begin{enumerate}
        \item $a \equiv a \pmod{n}$
        \item If $a \equiv b \pmod{n}$, then $b \equiv a \pmod{n}$
        \item If $a \equiv b \pmod{n}$ and $b \equiv c \pmod{n}$, then $a \equiv c \pmod{n}$
    \end{enumerate}
\end{lemma}

The lemma states three basic properties of congruence modulo $n$: reflexivity, symmetry, and transitivity. 
These properties confirm that congruence modulo $n$ is an equivalence relation (for general equivalence relation definition, see \Cref{section:relations}).

\begin{lemma}
    Suppose we have $a \equiv b \pmod{n}$ and $c \equiv d \pmod{n}$, then we have 
        \begin{enumerate}
            \item $a \pm c \equiv b \pm d \pmod{n}$
            \item $ac \equiv bd \pmod{n}$
        \end{enumerate}
\end{lemma}

In turn, this lemma states that we can perform addition, subtraction, and multiplication on the congruent numbers modulo $n$ similarly to the usual arithmetic.

\begin{lemma}
    If $ca \equiv cb \pmod{n}$ and $\gcd(c, n) = 1$, then $ a \equiv b \pmod{n}$.
\end{lemma}

This means that we can cancel out the same left and right parts respectively, but with a certain requirement. You may ask why this is necessary, the answer is in the following example.

\begin{example}
    Let us try to simplify the following equation: $6 \equiv 2 \pmod{4}$. Suppose we divide both sides by $2$, then we have the false statement $3 \equiv 1 \pmod{4}$. That being said, the requirement $\gcd(c, n) = 1$ is mandatory. 
\end{example}

\begin{remark}
    In particular, the example above shows why the division operation is fundamentally different from the regular real/rational numbers. We will see that, in fact, the arithmetic modulo $n$ is not always what mathematicians call a \textbf{field}. You will see more details in \Cref{section:field_extensions}.
\end{remark}

\begin{lemma} \label{lemma:congruence_scale}
    Modulo congruence can be scaled in both directions:
    
    \begin{enumerate}
        \item If $k \neq 0, a \equiv b \pmod{n}$, then $ak \equiv bk \pmod{nk}$
        \item If $d = \gcd(a, b, n) \text{ and } a = a_1d, b =b_1d, n = n_1d, a \equiv b \, (\text{mod } n)$, then $a_1 = b_1 \, (\text{mod } n_1)$
    \end{enumerate}
\end{lemma}

\begin{lemma}
    If $d \mid n$ and $a \equiv b \, (\text{mod } n)$, then $a \equiv b \, (\text{mod } d)$.
\end{lemma}

This property is very convenient when it comes to large calculations, if you know its decomposition.
It allows you to significantly reduce them, and then restore the result by a large modulus.

\begin{lemma}
    Suppose $a \equiv b \pmod{n_1}$, $a \equiv b \pmod{n_2}$, \ldots, $a \equiv b \pmod{n_k}$. Then, the following statement is true: 
    \begin{equation*}
        a \equiv b \pmod{\lcm(n_1, n_2, \dots, n_k)}.
    \end{equation*}
\end{lemma}

\begin{lemma}
    If $a \equiv b \, (\text{mod } n)$, then $\gcd(a, n) = \gcd(b, n)$
\end{lemma}

\begin{definition}
    The congruence class or residues of $k$ modulo $n$ is defined as a set $k + n\mathbb{Z} = \{ k + nt \mid t \in \mathbb{Z}\}$    
\end{definition}

\begin{definition}
    The \textbf{complete residue system modulo} (or residue ring) $n$ is a set of integers, where
    every integer is congruent to a unique member of the set modulo $n$, usually denoted
    as $\mathbb{Z}_n = \{0, 1, 2, \dots, n-1\}$.
\end{definition}

\begin{remark}
    Sometimes, one might also encounter the notation $\mathbb{Z}/n\mathbb{Z}$, which is more frequently used in Abstract Algebra.
\end{remark}

The aforementioned lemmas and definitions describe the properties of addition, subtraction, and multiplication. But what about division? To define the division (if such operation is valid at all), we need to consider the so-called \emph{modular multiplicative inverse}, which is usually denoted as $a^{-1} \, (\text{mod } n)$, similarly to real/rational numbers.

\begin{definition}
    A modular multiplicative inverse of an integer $a \in \mathbb{Z}$ modulo $n \in \mathbb{N}$ is such an integer $a^{-1}$ that satisfies $a \cdot a^{-1} \equiv a^{-1}a \equiv 1 \pmod{n}$.
\end{definition}

\begin{remark}
    (\textbf{Caution}): not all numbers have an inverse number!
\end{remark}

\begin{remark}
    The inverse (if exists) behaves similarly to the usual inverse over rations/reals. For example, $(a^{2})^{-1} = (a^{-1})^{2}$, which means, we can first find the inverse, then the squared value, and vice versa.
\end{remark}

The question then is when does the number have the inverse? Consider the following theorem.

\begin{theorem}\label{th:inverse_existence}
    Modular inverse $a^{-1} \pmod{n}$ exists if and only if $\gcd(a, n) = 1$.
\end{theorem}

Based on Extended Euclidean \Cref{alg:extended_euclidean} and \Cref{th:inverse_existence}, we build the algorithm that can verify an existence and find the inverse value.

\begin{algorithm}
    \caption{Modular multiplicative inverse algorithm} \label{alg:modular_inverse}
    \Input{$a, n$}
    \Output{$a^{-1}$}
        
    $(d, u, v) \gets \text{ExtendedEuclideanAlgorithm}(a, n)$ \Comment{See \Cref{alg:extended_euclidean}}

    \If{$d \neq 1$}{
        \textbf{return} inverse does not exist.
    } 

    \textbf{return} $u$
\end{algorithm}

\begin{remark}
    Note that the complexity of this algorithm is the same as for \Cref{alg:extended_euclidean}, which is $O(\log a \log n)$ bit operations.
\end{remark}

\begin{definition}
    The \textbf{multiplicative group of integers} modulo $n$, denoted as $\mathbb{Z}_n^{\times}$, is a set of natural numbers that are coprime to $n$ and less than $n$. In other words, $\mathbb{Z}_n^{\times} = \{a \in \mathbb{N}: \gcd(a, n) = 1\}$.
\end{definition}

The $\mathbb{Z}_{n}^{\times}$ is a fundamental object in number theory and 
plays a crucial role in cryptography, forming the basis almost for every cryptographic primitive.

\begin{definition} \label{def:euler_totient_function}
    \textbf{Euler's Totient Function} $\varphi(n)$ is the cardinality of the multiplication 
    group of integers $\mathbb{Z}_n^{\times}$. In other words, $\varphi(n) = |\mathbb{Z}_n^{\times}|$.
\end{definition}

\begin{remark}
    The alternative Euler's totient function intuition is following: $\varphi(n)$ counts all coprimes with $n$ in range $[1, n]$. 
\end{remark}

\begin{lemma} [Euler's totient function properties]
    \hfill
    \begin{enumerate}
        \item $\varphi(1) = 1$.
        \item $\varphi(p) = p - 1$, $p$ where is prime.
        \item $\varphi(pq) = \varphi(p) \cdot \varphi(q)$, where $p, q$ are primes.
        \item $\varphi(p^{\alpha}) = p^{\alpha} - p^{\alpha - 1}$, where  $p$ is prime.        
    \end{enumerate}    
\end{lemma}

\begin{corollary}
    For any number $n = p_{1}^{\alpha_1}p_{2}^{\alpha_2} \dots p_{t}^{\alpha_t}$ general formula for Euler's totient function is: 
    \begin{equation*}
        \varphi(n) = \prod_{i = 1}^{t} \left( p_{i}^{\alpha_i} - p_{i}^{\alpha_i - 1} \right) = n \prod_{i = 1}^{t} \left( 1 - \frac{1}{p_i} \right).
    \end{equation*}
\end{corollary}

\begin{example}
    \hfill

    \begin{itemize}
        \item $\varphi(107) = 106$, because $107$ is prime.
        \item $\varphi(123) = \varphi(3 \cdot 41) = \varphi(3)\varphi(41) = 2 \cdot 40 = 80$
        \item $\varphi(729) = \varphi(3^6) = 3^6 - 3^5 = 486$
    \end{itemize}
\end{example}

\subsection{Chinese Remainder Theorem}
The Chinese Remainder Theorem is a fundamental result in number theory
that provides an efficient method for solving congruence systems. It allows to
decompose a complex problem with large integers into several simpler 
problems with smaller modules. This decomposition reduces the required computational 
complexity, especially when working with large numbers, and is widely used 
in areas such as modular arithmetic, cryptography, and algorithmic number theory. 

\begin{theorem} [Chinese Remainder Theorem] \label{th:chinese_remainder_theorem}
    Suppose there is the following system
    \begin{equation*}    
        \begin{cases}
            x \equiv x_1 \pmod{n_1} \\
            x \equiv x_2 \pmod{n_2} \\
            x \equiv x_3 \pmod{n_3} \\
            \cdots \\
            x \equiv x_t \pmod{n_t} \\
        \end{cases}
    \end{equation*}
    where the $n_i$ are pairwise coprime and $x_1, x_2, \cdots x_t$ are fixed numbers. 
    Then there is unique solution in modulo $N = n_1n_2 \cdots n_t$.
\end{theorem}

In fact, we can easily find such solution. Let $N_i = N/n_i$ since $n_i$ are pairwise coprime one, 
for all $i$ has $\gcd(N_i, n_i) = 1$, and by the Extended Euclidean Algorithm, there exists an integer
$a_i$ such that $a_iN_i \equiv 1 \pmod{n_i}$. Thus, the solution is given by 
\begin{equation*}
    x = a_1N_1x_1 + a_2N_2x_2 + \cdots + a_tN_tx_t .
\end{equation*}
This expression provides the unique solution modulo \( N \), where \( N = n_1 n_2 \cdots n_t \). 
Beside, using this idea, we can write an efficient algorithm to compute \( x \) iteratively.

\subsection{Euler's Theorem}
% Now we introduce a fundamental result in Number Theory.

\begin{theorem} [Euler's]
    For all $n \in \mathbb{N}$ and $a \in \mathbb{Z}_n^{\times}$ 
    holds $a^{\varphi{n}} \equiv 1 \pmod{n}$.
\end{theorem}

$\blacktriangleright$ To prove this fact, we prove the following auxiliary lemma.

\begin{lemma}
    Suppose $a \in \mathbb{Z}_n^{\times}$. Denote by $a\mathbb{Z}_n^{\times} =
    \{ax: x \in \mathbb{Z}_n^{\times}\}$. Then, $\mathbb{Z}_n^{\times} =
    a\mathbb{Z}_n^{\times}$. In other words, elementwise multiplication by $a$
    permutes the elements of $\mathbb{Z}_n^{\times}$.
\end{lemma}

\textbf{Proof.} Our statement is equivalent to claiming that the 
function $f: \mathbb{Z}_n^{\times} \to a\mathbb{Z}_n^{\times}$ defined 
as $f(x) = ax \pmod{n}$ is a \textbf{bijection}. To show this, we need to prove the following 
three staments:
\begin{enumerate}
    \item \textbf{Correctness} is obvious since $ax$ is in $a\mathbb{Z}_n^{\times}$ if $x$ is in $\mathbb{Z}_n^{\times}$.
    \item \textbf{Injectivity}: we need to prove that if $f(x_1)=f(x_2)$ for two $x_1 \neq x_2 \in \mathbb{Z}_n^{\times}$, then 
    $x_1=x_2$. From the function definition, we have $ax_1=ax_2 \pmod{n}$. Following the \Cref{lemma:congruence_scale}, 
    we can cancel $a$ modulo $n$ as $a$ is coprime to $n$. Thus, $x_1=x_2$.
    \item \textbf{Surjectivity}: We need to prove that every element $y \in a\mathbb{Z}_n^{\times}$ has at least 
    one pre-image $f^{-1}(y)$. Indeed, in this case we have $ax \equiv y \pmod{n}$. Then, set $x := a^{-1}y \pmod {n}$. This 
    expression is well-defined as $a$ is coprime to $n$ and has an inverse.
\end{enumerate}

Therefore, $f$ is bijective and thus $\mathbb{Z}_n^{\times} = a\mathbb{Z}_n^{\times}$.

\vspace{10px}

So we know $a\mathbb{Z}_n^{\times} = \mathbb{Z}_n^{\times}$, how do we proceed? Notice that 
from the set equality follows the equality of the products of all elements. Let us write this down:
\begin{equation*}
    \prod_{i = 1}^{\varphi(n)} x_i \equiv \prod_{i = 1}^{\varphi(n)} a x_i \pmod{n} \implies \prod_{i = 1}^{\varphi(n)} x_i \equiv a^{\varphi(n)} \prod_{i = 1}^{\varphi(n)} x_i \pmod{n}
\end{equation*}    
    
Since all $x_i$ are coprime to $n$ by definition, we can cancel out the product
of all $x_i$ from both sides, leading to the conclusion of Euler's theorem.
$\blacktriangleleft$

\begin{corollary} \label{cor:fermat_little_theorem}
    If $p$ is a prime and $a$ is not divisible by $p$, then $a^{p - 1} \equiv 1 \pmod{p}$.
\end{corollary}
% Sometimes this result denote as Fermat's little theorem, but in order not to lose generality,
% we describe the theorem more generally.
This result is commonly known as Fermat's Little Theorem. However, to maintain generality, 
we state the theorem in a more general form below.

\begin{theorem} [Fermat's Little Theorem.] \label{th:fermat_little_theorem}
    Let $p$ is prime number. For any integer $a$, the following holds $a^{p} \equiv a \pmod{p}$.
\end{theorem}

Note that Euler's theorem is a generalization of Fermat's Little Theorem.

\subsection{Schwartz-Zippel Lemma}

\begin{lemma}\label{lemma:sz}
Let $\mathbb{F}$ be a field. Let $f(x_1, x_2, ..., x_n)$ be a polynomial of total degree $d$. Suppose that $f$ is not the zero polynomial. Let $S$ be
a finite subset of $\mathbb{F}$. Let $r_1, r_2, ... r_n$ be chosen at random uniformly and independently from $S$. Then the probability that 
$f(r_1, r_2, ..., r_n) = 0$ is $\le \frac{d}{|S|}$.
\end{lemma}

\begin{example}
Let $F = \F_3$, $f(x) = x^2 - 5x + 6$, $S = F$, $r \xleftarrow{R} \mathbb{F}_3$.

Schwartz-Zippel lemma says that the probability that $f(r) = 0$ is $\le \frac{2}{3}$.
\end{example}

\vspace{-0.5em}

Given two polynomials $P, Q$ with  degree $d$ in a field $\F_p$, for $r \xleftarrow{R} \mathbb{F}_3$: $\Pr[P(r) == Q(r)] \le \frac{d}{p}$.
For large fields, where  $\frac{d}{p}$ is negligible, this property allows to succinctly check the equality of polynomials.
Let $H(x) := P(x) - Q(x)$. Than for each $P(x) = Q(x) \rightarrow H(x) = 0$. Applying Schwartz-Zippel lemma, 
the probability of $H(x) = 0$ for $x \xleftarrow{R} \mathbb{F} $ is $\le \frac{d}{|S|}$.

\newpage

\end{document}
