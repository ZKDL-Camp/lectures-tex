\documentclass[../lecture-notes.tex]{subfiles}
\usepackage[T1]{fontenc}

\pgfplotsset{compat=1.18}

\begin{document}

\subsection{Plonk Arithmetization}

Consider we have a certain relation $\mathcal{R}$, which we would like to write
down into a processing-prone format. Plonk arithmetizes this relation into a set
of 8 polynomials, which are then used to verify the witness knowledge. Let us 
start with the concrete example.

\begin{example}
To begin with, observe this fairly simple relation
$\mathcal{R}_{\text{example}}$: suppose we have a public input $x \in
\mathbb{F}$ and public output $y \in \mathbb{F}$, and we want to prove the knowledge of $e \in
\mathbb{F}$ such that $e \times x + x - 1 = y$. Formally, we have the following relation:
\begin{equation*}
    \mathcal{R}_{\text{example}} = \left\{ \begin{matrix}
        \textbf{Public Statement:} & x, y \in \mathbb{F} \\
        \textbf{Witness}: & e \in \mathbb{F}
    \end{matrix} \; \Big| \; e \times x + x - 1 = y \right\}
\end{equation*}

\end{example}

\begin{remark}
    Note that of course, from $x$ and $y$, it is fairly simple to find $e$: simply take $\frac{1 - x + y}{x}$. However, the Plonk arithmetization 
    is not limited to this simple example, and can be applied to more complex relations, such as hash function pre-image knowledge or any NP statement.
\end{remark}

\subsubsection{Execution Trace}

Standard Plonk is defined as a system with two types of gates: \textbf{addition}
and \textbf{multiplication}. We would explain how to build custom gates later.
So, let us consider our program in terms of gates with left, right operands and
output. 

\begin{example}
    We need \textbf{three gates} to encode our program:
    \begin{enumerate}
        \item \textbf{Gate \#1}: left $e$, right $x$, output \(u = e \times x\)
        \item \textbf{Gate \#2}: left $u$, right $x$, output \(\upsilon = u \times x\)
        \item \textbf{Gate \#3}: left $\upsilon$, right $x$, output \(w = \upsilon + (-1)\)
    \end{enumerate}
\end{example}

You might have glanced the intuitive formation of what is called \textit{execution trace table} --- a matrix $T$ with columns $L$, $R$ and $O$ (it is common to denote those as $A, B, C$ to distinguish from another matrix we will discuss later).

\begin{example}
We might visualize the execution trace table $T$ for the example program as follows:

\begin{center}
\begin{tabular}{|c|c|c|}
\hline
A & B & C \\ \hline
2 & 3 & 6 \\ \hline
6 & 3 & 9 \\ \hline
9 & \xmark & 8 \\ \hline
\end{tabular}
\end{center}

Notice how the last row has no value in $B$ column (marked by \xmark) --- this is reasoned by the fact it is not a variable, but rather a constant, meaning it doesn't depend on execution.
\end{example}

\begin{remark}
    As you might notice, in contrast to classic R1CS (which we used for Groth16), the standard Plonk arithmetization as is
    only allows two input values to be processed at a time. This way, if Groth16 requires only one constraint 
    for verifying $x_1(x_2+x_3+x_4) = x_5$, Plonk would need three constraints to verify the same statement. 
    Custom gates partially solve this problem as we will see later, but it is important to keep in mind.
\end{remark}

\subsubsection{Encode the program}

It is essential to distinguish the definition of the program and its specific evaluation for the sake of simplicity and efficiency --- once having established encoding for the program, you might apply it for any reasonable inputs.
Therefore, let us at first focus on what defines whether execution trace table will be considered valid for our circuit, because having a table by itself does not tell much, since it can be populated with any values. 

For that reason, we would define two matrices --- $Q \in \mathbb{F}^{|T| \times 5}$ and $V \in \mathbb{F}^{|T| \times 3}$ where $|T|$ is the number of gates in the program.

\begin{definition}
$Q$ matrix has one row per each gate with columns $Q_L$, $Q_R$, $Q_O$, $Q_M$, $Q_C$. If columns $A$, $B$ and $C$ of the execution trace table form valid evaluation of the circuit, 
\[A_i Q_{Li} + B_i Q_{Ri} + A_i B_i Q_{Mi} + C_i Q_{Oi} + Q_{ci} = 0\]
\end{definition}

\begin{example}

For our program, we would have a following $Q$ table:
\begin{center}
\begin{tabular}{|c|c|c|c|c|}
\hline
$Q_L$ & $Q_R$ & $Q_M$ & $Q_O$ & $Q_c$ \\ 
\hline
0 & 0 & 1 & $-1$ & 0 \\ 
\hline
1 & 1 & 0 & $-1$ & 0 \\ 
\hline
1 & 0 & 0 & $-1$ & $-1$ \\ 
\hline
\end{tabular}
\end{center}

You can verify that our claim holds for aforementioned trace matrix:
\begin{align*}
  2 \times 0 + 3 \times 0 + 2 \times 3 \times 1 + 6 \times (-1) + 0 &= 0 \\
  6 \times 1 + 3 \times 1 + 6 \times 3 \times 0 + 9 \times (-1) + 0 &= 0 \\
  9 \times 1 + 0 \times 0 + 9 \times 0 \times 0 + 8 \times (-1) + (-1) &= 0 
\end{align*}
\end{example}

Now, we do have a way of encoding gates separately, yet in order to guarantee how result of one gate is carried in as input of the other (\textit{wirings}), we need another matrix --- $V$.

\begin{definition}
$V$ consists of indices of all inputs and intermediate values, so that if $T$ is a valid trace,
\[\forall i, j, k, l: (V_{i,j} = V_{k,l}) \Rightarrow (T_{i,j} = T_{k,l})\]
\end{definition}

\begin{example}
For our program, $V$ would look like following:
\begin{center}
\begin{tabular}{|c|c|c|}
\hline
L & R & O \\
\hline
0 & 1 & 2 \\
\hline
2 & 1 & 3 \\
\hline
3 &  & 4 \\
\hline
\end{tabular}
\end{center}
Here $0$ is an index of $e$, $1$ is an index of $x$, 2 --- $u$, 3 --- $\upsilon$ and $4$ --- output $w$.
\end{example}

\subsubsection{Custom Gates}
In order to reach beyond classical operations such as addition and multiplication, one may consider composing a custom gate. The main streamliner of this functionality is a matrix $Q$, using $5$ basic columns of which, you already may build custom logic.

\begin{example}
Our entire program may be encoded as one custom gate.
\begin{center}
$Q$: 
\begin{tabular}{|c|c|c|c|c|}
\hline
$Q_L$ & $Q_R$ & $Q_M$ & $Q_o$ & $Q_c$ \\ 
\hline
0 & 1 & 1 & $-1$ & $-1$ \\ 
\hline
\end{tabular}
\quad $V$:
\begin{tabular}{|c|c|c|}
\hline
L & R & O \\
\hline
0 & 1 & 2 \\
\hline
\end{tabular}
\quad $T$:
\begin{tabular}{|c|c|c|}
\hline
A & B & C \\
\hline
2 & 3 & 8 \\
\hline
\end{tabular}

\[2 \times 0 + 3 \times 1 + 2 \times 3 \times 1 + 8 \times (-1) + (-1) = 0\]
\end{center}
As you can see, custom gates can optimize quite a lot.
\end{example}

\begin{remark}
Real-world Plonk applications commonly have additional columns in the $Q$ matrix, enabling an even broader set of custom functionality.
\end{remark}

\subsubsection{Public Inputs}
With current design, there is no way to demonstrate that appropriate inputs are used in our program. One way of doing this is by incorporating them in three matrices.

\begin{example}
Consider, as if we added new \textit{selector} rows to $Q$ and tied them in $V$ and $T$:

\begin{center}
$Q$: 
\begin{tabular}{|c|c|c|c|c|}
\hline
$Q_L$ & $Q_R$ & $Q_M$ & $Q_o$ & $Q_c$ \\ 
\hline
-1 & 0 & 0 & 0 & 3 \\ 
\hline
-1 & 0 & 0 & 0 & 8 \\ 
\hline
1 & 1 & 1 & -1 & 1 \\ 
\hline
1 & -1 & 0 & 0 & 0 \\ 
\hline
\end{tabular}
\quad $V$:
\begin{tabular}{|c|c|c|}
\hline
L & R & O \\
\hline
0 &  &  \\
\hline
1 &  &  \\
\hline
2 & 0 & 3 \\
\hline
1 & 3 &  \\
\hline
\end{tabular}
\quad $T$:
\begin{tabular}{|c|c|c|}
\hline
A & B & C \\
\hline
3 &  &  \\
\hline
8 &  &  \\
\hline
2 & 3 & 8 \\
\hline
8 & 8 &  \\
\hline
\end{tabular}
\end{center}
\end{example}

The problem with this approach, is that now we have lost agnosticism in $Q$ and $V$ of concrete evaluations. In order to resolve this, we would define a separate one-column matrix named $\Pi$ (public inputs).

\begin{example}
With only $Q$ modified, we have:

\centering 
\begin{center}
\begin{tabular}{|c|}
\hline
$\Pi$ \\ 
\hline
3 \\ 
\hline
8 \\ 
\hline
0 \\ 
\hline
0 \\ 
\hline
\end{tabular} \hspace{1cm}
$Q$: 
\begin{tabular}{|c|c|c|c|c|}
\hline
$Q_L$ & $Q_R$ & $Q_M$ & $Q_o$ & $Q_c$ \\ 
\hline
-1 & 0 & 0 & 0 & 0 \\ 
\hline
-1 & 0 & 0 & 0 & 0 \\ 
\hline
1 & 1 & 1 & -1 & 1 \\ 
\hline
1 & -1 & 0 & 0 & 0 \\ 
\hline
\end{tabular}
\end{center}
\end{example}

\begin{definition}
Matrix $T$ with columns $A$, $B$ and $C$ encodes correct execution of the program, if:
\begin{enumerate}
    \item \(\forall i: A_i Q_{Li} + B_i Q_{Ri} + A_i B_i Q_{Mi} + C_i Q_{Oi} + Q_{ci} + \Pi_i = 0\)
    \item \(\forall i, j, k, l: (V_{i,j} = V_{k,l}) \Rightarrow (T_{i,j} = T_{k,l})\)
\end{enumerate}
\end{definition}

\subsubsection{Matrices to Polynomials}

Now we can traduce the sets of constraints on matrices to just a few equations
on polynomials, as we have already done for Groth16. Let $\omega$ be a primitive
$N$-th root of unity and let $\Omega = \{\omega^j: 0 \le j < N\}$. Let \(a, b, c,
q_L, q_R, q_M, q_O, q_C, \pi\) be polynomials of degree at most $N$ that
interpolate corresponding columns from matrices at the domain $H$. This means,
that \(\forall j: a(\omega^j) = A_j\) and the same for other columns.

Now we can reduce down our first condition to checking valid execution trace
into the following claim over polynomials:
\[\exists t \in \mathbb{F}[X]: \; aq_L + bq_R + abq_M + cq_O + q_C + \pi = z_{\Omega} t,\]
where $z_{\Omega}(X)$ is the vanishing polynomial $X^N - 1$.

The next step is to shrink the second condition imposed by the $V$ matrix. This
may be achieved by introducing the concept of permutation. 

\begin{remark}
Permutation of the set is commonly denoted as $\sigma$.
\end{remark}

\begin{example}
A permutation is a rearrangement of the set, which is in our case: 
\[\mathcal{I} = \{(i, j) : \text{such that } 0 \leq i < N, \text{ and } 0 \leq j < 3\}\]
The matrix $V$ induces a permutation of this set where $\sigma((i,j))$ is equal to the indices of the next occurrence of the value at position $(i,j)$. So, for our example:

\begin{center}
\quad $V$:
\begin{tabular}{|c|c|c|}
\hline
L & R & O \\
\hline
0 &  &  \\
\hline
1 &  &  \\
\hline
2 & 0 & 3 \\
\hline
1 & 3 &  \\
\hline
\end{tabular}
\end{center}

\[\sigma((0,0)) = (2,1), \sigma((0,1)) = (0,3), \sigma((0,2)) = (0,2)\]
\[\sigma((0,3)) = (0,1), \sigma((2,1)) = (0,0), \sigma((3,1)) = (2,2)\]
\end{example}

Having defined permutation, we can now reduce a condition $2$ of valid execution trace matrix into the following check:
\[\forall (i, j) \in \mathcal{I}: T_{i,j} = T_{\sigma(i,j)}\]

You may have noticed how this can be reformulated as equality of $A$ and $B$:
\[A = \{((i, j), T_{i,j}) : (i, j) \in \mathcal{I}\}\]
\[B = \{(\sigma((i, j)), T_{i,j}) : (i, j) \in \mathcal{I}\}\]

We can reduce this check down to polynomial equations.

Suppose we have sets \(A = \{a_0, a_1\}\) and \(B = \{b_0, b_1\}\). We can consider polynomials \(A' = \{a_0 + X, a_1 + X\}, B' = \{b_0 + X, b_1 + X\}\). 
\\
So, \(A' = B'\), only if \((a_0 + X)(a_1 + X) = (b_0 + X)(b_1 + X)\). This is true because of linear polynomial unique factorization property, working as prime factors. Now, we can utilize Schwartz-Zippel lemma to replace the latter formula with \((a_0 + \gamma)(a_1 + \gamma) = (b_0 + \gamma)(b_1 + \gamma)\) for some random $\gamma$ with high probability
If we wish to generalize this for sets \(A = \{a_0, \ldots, a_{k-1}\}\) and \(B = \{b_0, \ldots, b_{k-1}\}\):

\[\prod_{i=0}^{k-1} (a_i + \gamma) = \prod_{i=0}^{k-1} (b_i + \gamma)\]

Let $H$ be a domain of the form \(\{1, \omega, \dots, \omega^{k-1}\}\) for some $k$-th root of unity $\omega$. Let $f$ and $g$ be polynomials that interpolate the following values at $H$:

\[f: (a_0 + \gamma, \ldots, a_{k-1} + \gamma)\]
\[g: (b_0 + \gamma, \ldots, b_{k-1} + \gamma)\]

Then \(\prod_{i=0}^{k-1} (a_i + \gamma) = \prod_{i=0}^{k-1} (b_i + \gamma)\) if only if: \(\exists Z \forall h \in H: Z(\omega^{0}) = 1\) and  \(Z(h)f(h) = g(h)Z(\omega h)\).

Now that we can encode equality of sets of field elements, let's expand this to sets of tuples of field elements.

Let \(A = \{(a_0, a_1), (a_2, a_3)\}\) and \(B = \{(b_0, b_1), (b_2, b_3)\}\), then, similarly to the previous:
\[A' = \{a_0 + a_1Y + X, a_2 + a_3Y + X\}\]
\[B' = \{b_0 + b_1Y + X, b_2 + b_3Y + X\}\]
\[A = B \leftrightarrow A' = B'\]

As before, we can leverage Schwartz-Zippel lemma to reduce this down into sampling random $\beta$ and $\gamma$ and checking equality of:

\[(a_0 + \beta a_1 + \gamma)(a_2 + \beta a_3 + \gamma) = (b_0 + \beta b_1 + \gamma)(b_2 + \beta b_3 + \gamma)\]
\\
Now, if we would go back into condition 2 which we are trying to formulate in polynomial domain, it will become clear that first if we somehow encode inner indices tuple $(i, j)$ into a one field element, we can use the above fact.
Recall that $i \in [0; N-1]$ and $j \in [0; 2]$; we can take $3N$-th primitive root of unity $\eta$ and define our field element as \(a_0 = \eta^{3i + j}\):
\[A = \{(\eta^{3i+j}, T_{i,j}) : (i, j) \in I\}\]
\[B = \{(\eta^{3k+l}, T_{i,j}) : (i, j) \in I, \sigma((i, j)) = (k, l)\}\]

Then, summarizing:
Let $\eta$ be a $3N$-th primitive root of unity, $\beta$ and $\gamma$ random field elements. Let $D = \{1, \eta, \eta^2, \ldots, \eta^{3N-1}\}$. Then let $f$ and $g$ interpolate at $D$:

\[f: \{T_{i,j} + \eta^{3i+j}\beta + \gamma : (i, j) \in I\}\]
\[g: \{T_{i,j} + \eta^{3k+l}\beta + \gamma : (i, j) \in I, \sigma((i, j)) = (k, l)\}\]

So, \(\exists Z \forall h \in H: Z(\eta^{0}) = 1\) and  \(Z(h)f(h) = g(h)Z(\eta h) \leftrightarrow A = B\) w.h.p.

Notice, that $\omega = \eta^3$ is a primitive $N$-th root of unity. Let \(H = \{1, \omega, \omega^2, \ldots, \omega^{N-1}\}\). 
We will define three polynomials, which interpolate following sets:
\[S_{\sigma 1}: \{\eta^{3k+l} : (i, 0) \in I, \sigma((i, 0)) = (k, l)\}\]
\[S_{\sigma 2}: \{\eta^{3k+l} : (i, 1) \in I, \sigma((i, 0)) = (k, l)\}\]
\[S_{\sigma 3}: \{\eta^{3k+l} : (i, 2) \in I, \sigma((i, 0)) = (k, l)\}\]
\\
Let $\omega$ be an $N$-th root of unity. Let $H = \{1, \omega, \omega^2, \ldots, \omega^{N-1}\}$. Let $k_1$ and $k_2$ be two field elements such that $\omega^i \neq \omega^j k_1 \neq \omega^l k_2$ for all $i, j, l$. Let $\beta$ and $\gamma$ be random field elements. Let $f$ and $g$ be the polynomials that interpolate, respectively, the following values at $H$:

\[f: \left\{\left(T_{0,j} + \omega^i \beta + \gamma\right)\left(T_{1,j} + \omega^i k_1 \beta + \gamma\right)\left(T_{2,j} + \omega^i k_2 \beta + \gamma\right) : 0 \leq i < N\right\}\]
\[g: \left\{\left(T_{0,j} + S_{0,1}(\omega^i) \beta + \gamma\right)\left(T_{0,j} + S_{0,2}(\omega^i) \beta + \gamma\right)\left(T_{0,j} + S_{0,3}(\omega^i) \beta + \gamma\right) : 0 \leq i < N\right\}\]

So, \(\exists Z \forall h \in D: Z(\omega^{0}) = 1\) and  \(Z(d)f(d) = g(d)Z(\omega d) \leftrightarrow A = B\) w.h.p.

So, we now can encode our program using 8 polynomials mentioned at the beginning:
\[q_L, q_R, q_M, q_O, q_C, S_{01}, S_{02}, S_{03}\]
These are called \textit{common preprocessed input}.

\subsubsection{Summary}
Having a program for relation $\mathcal{R}$, we saw how it can be represented as
a sequence of gates with left, right operands and output. The circuit may be
encoded using two matrices $Q$ --- for capturing gates, and $V$ --- for encoding
value carries (\textit{wirings}). Upon execution, we get trace execution matrix
$T$ and $\Pi$ for public inputs.

\begin{definition}
Let $T$ be a $N \times 3$ matrix with columns $A, B, C$ and $\Pi$ a $N \times 1$
matrix where $N$ is the number of gates. They correspond to a valid execution
instance with public input given by $\Pi$ if and only if:

\begin{enumerate}
    \item \(\forall i: A_iQ_{Li} + B_iQ_{Ri} + A_iB_iQ_{Mi} + C_iQ_{Oi} + Q_{Ci} + \Pi_i = 0\)
    \item \(\forall i, j, k, l: V_{i,j} = V_{k,l} \implies T_{i,j} = T_{k,l}\)
    \item \(\forall i > n: \Pi_i = 0\)
\end{enumerate}
\end{definition}

When, we encode those conditions in terms of polynomials.

\begin{definition}
Let $z_{\Omega} = X^N - 1$. Let $T$ be a $N \times 3$ matrix with columns $A, B,
C$ and $\Pi$ a $N \times 1$ matrix. They correspond to a valid execution
instance with public input given by $\Pi$ if and only if:

\begin{enumerate}
    \item \(\exists t_1 \in \mathbb{F}[X]: aq_L + bq_R + abq_M + cq_O + q_C + \pi = z_{\Omega}t_1\)
    \item \(\exists t_2, t_3, z \in \mathbb{F}[X]: zf - gz' = z_{\Omega}t_2\) and \((z-1)L_1 = z_{\Omega}t_3\), where $z'(X) = z(X\omega)$.
\end{enumerate}
\end{definition}
\begin{remark}
We can reduce every needed check down to one equation, if we introduce randomness.
Let $\alpha$ be a random field element, then: 
\[
    \begin{aligned}
        z_Ht &= aq_L + bq_R + abq_M + cq_O + q_C + \pi \\
        &= \alpha(gz' - fz) \\
        &= \alpha^2(z - 1)L_1
    \end{aligned}
\]
\end{remark}

\end{document}