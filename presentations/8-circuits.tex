\documentclass{zkdl-presentation-template}

\title[zk-SNARK: Part I]{\textbf{Introduction to zk-SNARKs. R1CS}}
\author{Distributed Lab}
\date{September 12, 2024}
\homepage{zkdl-camp.github.io}
\github{ZKDL-Camp}

\begin{document}
\frame {
    \tikz [remember picture,overlay]
    \node at
        ([yshift=1.5cm,xshift=-1.5cm]current page.south east) 
        %or: (current page.center)
        {\includegraphics[width=60pt]{images/logo.png}};
    \titlepage
    }

    \begin{frame}{Plan}
        \tableofcontents
    \end{frame}

    \section{What is zk-SNARK?}

    \begin{frame}{What Is zk-SNARK?}
        \begin{definition}
            \begin{center}
                \textbf{zk-SNARK} \\
                \textbf{Z}ero-\textbf{K}nowledge \textbf{S}uccinct \textbf{N}on-interactive \textbf{AR}gument of \textbf{K}nowledge.
            \end{center}
        \end{definition}

        

        \begin{itemize}
            \item \textbf{Argument of Knowledge} --- a proof that the prover knows the data (witness) that resolves a certain
            problem, and this knowledge can be ``extracted''. 
            \item \textbf{Succinctness} --- the proof size and verification time is relatively small to the computation size and typically does not depend on the size of 
            the data or statement. 
            \item \textbf{Non-interactiveness} --- to produce the proof, the prover does not need any interaction
            with the verifier. 
            \item \textbf{Zero-Knowledge} --- the verifier learns nothing about the data used to produce the
            proof, despite knowing that this data resolves the given problem and that the prover possesses it.
        \end{itemize}
    \end{frame}

    \begin{frame}{Still don't get who is SNARK...}
        Well... Let's take a look at some example. 

        \begin{columns}
            \begin{column}{0.2\textwidth}
                \includegraphics[width=\linewidth]{../presentations/images/lecture_8/urtreasurehunter.png}
            \end{column}
    
            \begin{column}{0.7\textwidth}
                Imagine you're part of a treasure hunt...
            \end{column}
        \end{columns}

        

        \begin{columns}
            \begin{column}{0.7\textwidth}
                ...and you've found a hidden treasure chest...
            \end{column}

            \begin{column}{0.2\textwidth}
                \includegraphics[width=\linewidth]{../presentations/images/lecture_8/uvefoundtreasure.png}
            \end{column}
        \end{columns}

        

        \begin{columns}
            \begin{column}{0.2\textwidth}
                \includegraphics[width=\linewidth]{../presentations/images/lecture_8/howtomakeaproof.png}
            \end{column}

            \begin{column}{0.7\textwidth}
                ...but how to prove that without revealing the chest location?
            \end{column}
        \end{columns}
    \end{frame}

    \begin{frame}{Still don't get who is SNARK...}
        \begin{columns}
            \begin{column}{0.65\textwidth}
                \begin{block}{The Problem}
                You have found a hidden treasure chest, and you want to 
                prove to the organizer that you know its location without actually revealing that.
                \end{block}
            \end{column}

            \begin{column}{0.3\textwidth}
                \includegraphics[width=\textwidth]{../presentations/images/lecture_8/treasurelocation.png}
            \end{column}
        \end{columns}

        

        We can retrieve some information from that:

        \vspace{0.1cm}
        \textbf{The Secret Data}: the exact treasure location.

        \vspace{0.1cm}
        \textbf{The Prover}: you.

        \vspace{0.1cm}
        \textbf{The Verifier}: the treasure hunt organizer.
    \end{frame}

    \begin{frame}{Ohh... Got it!}
        Here is how we can apply the zk-SNARK to our problem:

        \begin{itemize} 
            \item \textbf{Argument of Knowledge}: You need to create a proof that demonstrates you know the
            chest is. 
            \item \textbf{Succinct}: The proof you provide is very small and concise. It doesn't matter how
            large the treasure map is or how many steps it took you to find the chest. 
            \item \textbf{Non-interactive}: You don't need to have a back-and-forth conversation with the 
            organizer to create this proof. 
            \item \textbf{Zero-Knowledge}: The proof doesn't reveal any information about the actual 
            location of the treasure chest.
        \end{itemize}
         \vspace{-10pt}
        \begin{columns}
            \begin{column}{0.3\textwidth}
                \includegraphics[width=\textwidth]{../presentations/images/lecture_8/treasure.png}
            \end{column}

            \begin{column}{0.65\textwidth}
                Well... The golden coin where the pirates' sign is engraved is our zk-SNARK proof!
            \end{column}
        \end{columns}
    \end{frame}

    \begin{frame}{The First Question To Resolve}
        But the problems that we usually want to solve are in a slightly different format.
        

        \vspace{0.1cm}
        When we need to prove that some element is in a merkle tree, we can't come
        to a verifier and give them a "coin"...
        
        
        \begin{alertblock}{Question?}
            How do we convert a program into a mathematical language?
        \end{alertblock}

        \center
        \includegraphics[width=9cm]{../presentations/images/lecture_8/exactcodetomathflow.png}
    \end{frame}

    \section{Boolean Circuits}

    \begin{frame}{Boolean Circuits}
        We can do that in a way like the computer does it --- \textbf{Boolean Circuits}.

        % --- Writing diagrams ---
        % Define circle styles and colors
        \colorlet{circle edge}{gray!50!black}
        \colorlet{circle area}{gray!20}
        \colorlet{gate1 edge}{oc-green-9}
        \colorlet{gate1 area}{oc-green-2}
        \colorlet{gate2 edge}{oc-yellow-9}
        \colorlet{gate2 area}{oc-yellow-2}
        \colorlet{gate3 edge}{oc-indigo-9}
        \colorlet{gate3 area}{oc-indigo-2}

        \tikzset{
            var/.style={circle, draw=circle edge, fill=circle area, very thick, minimum size=0.7cm, text centered},
            gate1/.style={circle, draw=gate1 edge, fill=gate1 area, ultra thick, minimum size=1cm, text centered},
            gate2/.style={circle, draw=gate2 edge, fill=gate2 area, ultra thick, minimum size=1cm, text centered},
            gate3/.style={circle, draw=gate3 edge, fill=gate3 area, ultra thick, minimum size=1cm, text centered},
            arrow/.style={-latex, ultra thick}
        }

        \begin{columns}
            % Description
            \begin{column}{0.7\textwidth}
                \centering
                \begin{minipage}{0.8\textwidth}
                    \centering
                    % Boolean AND and OR gates
                    \begin{tabular}{cc}
                        \begin{tikzpicture}
                            % Nodes
                            \node[var] (a) at (0, -1.5) {$a$};
                            \node[var] (b) at (2, -1.5) {$b$};
                            \node[gate1] (and) at (1, 0) {\texttt{AND}};
                            \node[var] (c) at (1, 1.75) {$c$};
            
                            % Arrows
                            \draw[arrow,gray] (a) -- (and);
                            \draw[arrow,gray] (b) -- (and);
                            \draw[arrow,gray!50!black] (and) -- (c);
                        \end{tikzpicture}
                        &
                        \begin{tikzpicture}
                            % Nodes
                            \node[var] (a) at (0, -1.5) {$a$};
                            \node[var] (b) at (2, -1.5) {$b$};
                            \node[gate2] (or) at (1, 0) {\texttt{OR}};
                            \node[var] (c) at (1, 1.75) {$c$};
            
                            % Arrows
                            \draw[arrow,gray] (a) -- (or);
                            \draw[arrow,gray] (b) -- (or);
                            \draw[arrow,gray!50!black] (or) -- (c);
                        \end{tikzpicture}
                    \end{tabular}
                    %\centering
                    %\caption{Boolean \texttt{AND} and \texttt{OR} Gates}
                \end{minipage}
            \end{column}

            % Column 2    
            \begin{column}{0.3\textwidth}
                \begin{minipage}{\textwidth}
                \centering
                \begin{tabular}{|c|c|c|}
                    \hline
                    \textbf{A} & \textbf{B} & \textbf{A AND B} \\
                    \hline
                    0 & 0 & 0 \\
                    \hline
                    0 & 1 & 0 \\
                    \hline
                    1 & 0 & 0 \\
                    \hline
                    1 & 1 & 1 \\
                    \hline
                \end{tabular}
                %\caption{\texttt{AND} Gate Truth Table}
            \end{minipage}
        \end{column}
        \end{columns}

        \begin{block}{Note}
        With any of \{\texttt{AND}, \texttt{NOT}\} or \{\texttt{OR}, \texttt{NOT}\} gates sets one can
        build any possible logical circuit, they are called \textbf{functionally complete} sets.
        \end{block}
    \end{frame}

    \begin{frame}{Boolean Circuit Example}
        % --- Writing diagrams ---
        % Define circle styles and colors
        \colorlet{circle edge}{gray!50!black}
        \colorlet{circle area}{gray!20}
        \colorlet{gate1 edge}{oc-green-9}
        \colorlet{gate1 area}{oc-green-2}
        \colorlet{gate2 edge}{oc-yellow-9}
        \colorlet{gate2 area}{oc-yellow-2}
        \colorlet{gate3 edge}{oc-indigo-9}
        \colorlet{gate3 area}{oc-indigo-2}

        \tikzset{
            var/.style={circle, draw=circle edge, fill=circle area, very thick, minimum size=0.7cm, text centered},
            gate1/.style={circle, draw=gate1 edge, fill=gate1 area, ultra thick, minimum size=1cm, text centered},
            gate2/.style={circle, draw=gate2 edge, fill=gate2 area, ultra thick, minimum size=1cm, text centered},
            gate3/.style={circle, draw=gate3 edge, fill=gate3 area, ultra thick, minimum size=1cm, text centered},
            arrow/.style={-latex, ultra thick}
        }

        \begin{figure}[h!]
            \centering
            \begin{tikzpicture}
                % Nodes
                \node[var] (a) at (0, -1.5) {$a$};
                \node[var] (b) at (2, -1.5) {$b$};
                \node[var] (c) at (4, -1.5) {$c$};
                \node[gate1] (and) at (1, 0) {\texttt{AND}};
                \node[gate2] (or) at (3, 1.5) {\texttt{OR}};
                \node[var] (d) at (5, 1.5) {$d$};
        
                % Arrows
                \draw[arrow,gray] (a) -- (and);
                \draw[arrow,gray] (b) -- (and);
                \draw[arrow,gray] (c) -- (or);
                \draw[arrow,gray] (and) -- (or);
                \draw[arrow,gray!50!black] (or) -- (d);
            \end{tikzpicture}
            \vspace{-5pt}
            \caption{Example of a circuit evaluating $d = (a \;\texttt{AND}\; b) \,\texttt{OR}\; c$.}
        \end{figure}
        \vspace{-5pt}
        Boolean circuits receive an input vector of {0, 1} and resolve to true (1) or false (0);\\
        \vspace{5pt}
        The above circuit can be satisfied with the next values:
        \vspace{-5pt}
        \begin{equation*}
            a = 1, \quad b = 1, \quad c = 0, \quad d = 1
        \end{equation*}
    \end{frame}

    \begin{frame}{SHA-256 Boolean circuit}
        \begin{figure}[h!]
            \centering
            \includegraphics[width=8cm]{../presentations/images/lecture_8/sha256booleancircuit.jpg}
            \caption{Stats of a SHA256 boolean circuit implementation.}
        \end{figure}
        More than $100000$ gates. Impressive, isn't it? \\
        \vspace{5pt }
        But it also shows how inconvenient the boolean circuits are. 
    \end{frame}

    \section{Arithmetic Circuits}

    \begin{frame}{Arithmetic Circuits}
        Similar to Boolean Circuits, the \textbf{Arithmetic Circuits} consist of gates and
        wires. 
        \begin{itemize}
            \item \textbf{Wires}: elements of some finite field $\mathbb{F}$.
            \item \textbf{Gates}: field addition ($+$) and multiplication ($\times$).
        \end{itemize} 

        % --- Writing diagrams ---
        % Define circle styles and colors
        \colorlet{circle edge}{gray!50!black}
        \colorlet{circle area}{gray!20}
        \colorlet{gate1 edge}{oc-green-9}
        \colorlet{gate1 area}{oc-green-2}
        \colorlet{gate2 edge}{oc-yellow-9}
        \colorlet{gate2 area}{oc-yellow-2}
        \colorlet{gate3 edge}{oc-indigo-9}
        \colorlet{gate3 area}{oc-indigo-2}

        \tikzset{
            var/.style={circle, draw=circle edge, fill=circle area, very thick, minimum size=0.7cm, text centered},
            gate1/.style={circle, draw=gate1 edge, fill=gate1 area, ultra thick, minimum size=1cm, text centered},
            gate2/.style={circle, draw=gate2 edge, fill=gate2 area, ultra thick, minimum size=1cm, text centered},
            gate3/.style={circle, draw=gate3 edge, fill=gate3 area, ultra thick, minimum size=1cm, text centered},
            arrow/.style={-latex, ultra thick}
        }

        \begin{figure}[h!]
            \centering
            % Addition and Multiplication gates
            \begin{tabular}{cc}
                \begin{tikzpicture}
                    % Nodes
                    \node[var] (a) at (0, -1.5) {$a$};
                    \node[var] (b) at (2, -1.5) {$b$};
                    \node[gate1] (add) at (1, 0) {$+$};
                    \node[var] (c) at (1, 1.75) {$c$};

                    % Arrows
                    \draw[arrow,gray] (a) -- (add);
                    \draw[arrow,gray] (b) -- (add);
                    \draw[arrow,gray!50!black] (add) -- (c);
                \end{tikzpicture}
                &
                \begin{tikzpicture}
                    % Nodes
                    \node[var] (a) at (0, -1.5) {$a$};
                    \node[var] (b) at (2, -1.5) {$b$};
                    \node[gate2] (mul) at (1, 0) {$\times$};
                    \node[var] (c) at (1, 1.75) {$c$};

                    % Arrows
                    \draw[arrow,gray] (a) -- (mul);
                    \draw[arrow,gray] (b) -- (mul);
                    \draw[arrow,gray!50!black] (mul) -- (c);
                \end{tikzpicture}
            \end{tabular}
            \caption{Addition and Multiplication Gates}
        \end{figure}
    \end{frame}
 
    \begin{frame}[fragile]{Arithmetic Circuits Example I}
        \begin{example}
            \begin{lstlisting}[language=Python, numbers=none, autogobble=true, xleftmargin=10pt]
                def multiply(a: F, b: F) -> F:
                    return a * b
            \end{lstlisting}
            
            This can be represented as a circuit with only one (multiplication) gate:
            \begin{equation*}
                r = a \times b
            \end{equation*}    
            
            The witness vector (essentially, our solution vector) is $\boldsymbol{w} = (r, a, b)$, for
            example: $(6, 2, 3)$. \\
            \vspace{5pt}
            We assume that the $a$ and $b$ are input values.
        \end{example}

        

        \begin{block}{Note}
            We can think of the ``=`` in the gate as an assertion.
        \end{block}
    \end{frame}

    \begin{frame}[fragile]{Arithmetic Circuits Example II}
        \begin{example}
            Now, suppose we want to implement the evaluation of the polynomial
            $Q(x_1,x_2) = x_1^3 + x_2^2 \in \mathbb{F}[x_1,x_2]$ using arithmetic circuits.
            \begin{lstlisting}[language=Python, numbers=none, autogobble=true, xleftmargin=10pt]
                def evaluate(x1: F, x2: F) -> F:
                    return x1**3 + x2**2
            \end{lstlisting}
            Looks easy, right?  But the circuit is now much less trivial.
            \vspace{-8pt}
            \begin{equation*}
                \begin{array}{c c c}
                    \begin{aligned}
                        x_1^2 &= x_1 \times x_1 \\
                        x_1^3 &= x_1^2 \times x_1 \\
                        x_2^2 &= x_2 \times x_2 \\
                        Q &= x_1^3 + x_2^2 
                    \end{aligned}
                    & \text{or} &
                    \begin{aligned}
                        r_1 &= x_1 \times x_1 \\
                        r_2 &= r_1 \times x_1 \\
                        r_3 &= x_2 \times x_2 \\
                        Q &= r_2 + r_3 
                    \end{aligned}
                \end{array}
            \end{equation*}
        \end{example}
    \end{frame}

    \begin{frame}[fragile]{Arithmetic Circuits Example II}
        % Define circle styles and colors
        \colorlet{circle edge}{gray!50!black}
        \colorlet{circle area}{gray!20}
        \colorlet{gate1 edge}{oc-green-9}
        \colorlet{gate1 area}{oc-green-2}
        \colorlet{gate2 edge}{oc-yellow-9}
        \colorlet{gate2 area}{oc-yellow-2}
        \colorlet{gate3 edge}{oc-indigo-9}
        \colorlet{gate3 area}{oc-indigo-2}

        \tikzset{
            var/.style={circle, draw=circle edge, fill=circle area, very thick, minimum size=0.7cm, text centered},
            gate1/.style={circle, draw=gate1 edge, fill=gate1 area, ultra thick, minimum size=1cm, text centered},
            gate2/.style={circle, draw=gate2 edge, fill=gate2 area, ultra thick, minimum size=1cm, text centered},
            gate3/.style={circle, draw=gate3 edge, fill=gate3 area, ultra thick, minimum size=1cm, text centered},
            arrow/.style={-latex, ultra thick}
        }
        
        \begin{figure}[h!]
            \centering
            \begin{tikzpicture}
                % Nodes
                \node[var] (x1) at (0, 1) {$x_1$};
                \node[gate2] (x1_x1) at (2, 1) {$\times$};
                \node[gate2] (x1_x1_x1) at (4, 1) {$\times$};
        
                \node[var] (x2) at (0, -1) {$x_2$};
                \node[gate2] (x2_x2) at (2, -1) {$\times$};
        
                \node[gate1] (plus) at (5.0, -0.5) {$+$};
        
                % x1**3
                \draw[arrow,gray] (x1) to [bend left=45] (x1_x1);
                \draw[arrow,gray] (x1) to [bend right=15] (x1_x1);
                \draw[arrow,gray] (x1_x1) -- node[midway, above] {$x_1^2$} (x1_x1_x1);
                \draw[arrow,gray] (x1) to [bend right=45] node[midway, above] {$x_1$} (x1_x1_x1);
        
                % x2**2
                \draw[arrow,gray] (x2) to [bend left=30] (x2_x2);
                \draw[arrow,gray] (x2) to [bend right=30] (x2_x2);
        
                % Summation
                \draw[arrow,gray] (x1_x1_x1) -- node[midway, above right] {$x_1^3$} (plus);
                \draw[arrow,gray] (x2_x2) -- node[midway, above] {$x_2^2$} (plus);
        
                % Result
                \node[var] (q) at (7.0, -0.5) {$Q$};
                \draw[arrow,gray!50!black] (plus) -- (q);
            \end{tikzpicture}
            \caption{Example of a circuit evaluating $x_1^3 + x_2^2$.}
        \end{figure}
    \end{frame}

    \begin{frame}[fragile]{Arithmetic Circuits Example III}
        \begin{example}
            Well, it is quite clear how to represent any polynomial-like expressions. But how can we
            translate \texttt{if} statements?
            \begin{lstlisting}[language=Python, numbers=none, autogobble=true, xleftmargin=8pt]
                def example(a: bool, b: F, c: F) -> F:
                    if a:
                        return b * c 
                    else:
                        return b + c
            \end{lstlisting}
            
            We can transform such a function into the next expression:
            \vspace{-8pt}
            \begin{equation*}
                r = a \times (b \times c) + (1 - a) \times (b + c)    
                \vspace{-8pt}
            \end{equation*}
            
            Corresponding equations for the circuit are:
            \vspace{-8pt}
            \begin{equation*}
                \begin{aligned}
                    r_1 &= b \times c, \quad &r_3 &= 1 - a, \quad &r_5 &= r_3 \times r_2 \\
                    r_2 &= b + c, \quad &r_4 &= a \times r_1, \quad &r &= r_4 + r_5
                \end{aligned}
            \end{equation*}
        \end{example}
    \end{frame}

    \begin{frame}[fragile]{Arithmetic Circuits Example III}
        % Define circle styles and colors
        \colorlet{circle edge}{gray!50!black}
        \colorlet{circle area}{gray!20}
        \colorlet{gate1 edge}{oc-green-9}
        \colorlet{gate1 area}{oc-green-2}
        \colorlet{gate2 edge}{oc-yellow-9}
        \colorlet{gate2 area}{oc-yellow-2}
        \colorlet{gate3 edge}{oc-indigo-9}
        \colorlet{gate3 area}{oc-indigo-2}

        \tikzset{
            var/.style={circle, draw=circle edge, fill=circle area, very thick, minimum size=0.7cm, text centered},
            gate1/.style={circle, draw=gate1 edge, fill=gate1 area, ultra thick, minimum size=1cm, text centered},
            gate2/.style={circle, draw=gate2 edge, fill=gate2 area, ultra thick, minimum size=1cm, text centered},
            gate3/.style={circle, draw=gate3 edge, fill=gate3 area, ultra thick, minimum size=1cm, text centered},
            arrow/.style={-latex, ultra thick}
        }

        \begin{figure}[h!]
            \centering
            \begin{tikzpicture}
                % Nodes
                \node[var] (c) at (0.5, -3) {$c$};
                \node[var] (b) at (0.5, -1.5) {$b$};
                \node[var] (a) at (0.5, 0) {$a$};
                \node[var] (one) at (0.5, 1.5) {$1$};
        
                % b+c and b*c gates
                \node[gate1] (b_plus_c) at (3, -1.5) {$+$};
                \node[gate2] (b_times_c) at (3, -3.0) {$\times$};
        
                \node[gate3] (one_minus_a) at (3, 0.75) {$-$};
        
                % a*b*c and (1-a)(b+c) gates
                \node[gate2] (a_times_b_times_c) at (6, -2.0) {$\times$};
                \node[gate2] (one_minus_a_times_b_plus_c) at (6, -0.5) {$\times$};
        
                % a*b*c + (1-a)(b+c) gate
                \node[gate1] (r) at (9, -1.25) {$+$};
        
                % Result node
                \node[var] (result) at (11.5, -1.25) {$r$};
        
                % b+c and b*c arrows
                \draw[arrow,gray] (b) to (b_plus_c);
                \draw[arrow,gray] (b) to (b_times_c);
                \draw[arrow,gray] (c) to (b_plus_c);
                \draw[arrow,gray] (c) to (b_times_c);
        
                % 1 - c arrow
                \draw[arrow,gray] (one) to (one_minus_a);
                \draw[arrow,gray] (a) to (one_minus_a);
        
                % a*b*c and (1-a)(b+c) arrows
                \draw[arrow,gray] (a) to [bend left=20] (a_times_b_times_c);
                \draw[arrow,gray] (b_times_c) to node[midway, above] {$r_1$} (a_times_b_times_c);
                \draw[arrow,gray] (one_minus_a) to node[midway, above] {$r_3$} (one_minus_a_times_b_plus_c);
                \draw[arrow,gray] (b_plus_c) to node[midway, above] {$r_2$} (one_minus_a_times_b_plus_c);
        
                % a*b*c + (1-a)(b+c) arrows
                \draw[arrow,gray] (a_times_b_times_c) to [bend right=20] node[midway, above] {$r_4$} (r);
                \draw[arrow,gray] (one_minus_a_times_b_plus_c) to [bend left=20] node[midway, above] {$r_5$} (r);
        
                % Result arrow
                \draw[arrow,gray!50!black] (r) to (result);
        
            \end{tikzpicture}
            \caption{Example of a circuit evaluating the \texttt{if} statement logic.}
            \label{fig:multivariate-polynomial-circuit}
        \end{figure}
    \end{frame}

    \section{Linear Algebruh Preliminaries}

    \begin{frame}{Vector Space}
        \begin{definition}
            A \textbf{vector space} $V$ over the field $\mathbb{F}$ is an abelian group for addition
            ``$+$`` together with a scalar multiplication operation ``$\cdot$`` from $\mathbb{F} \times V$
            to $V$, sending $(\lambda,x) \mapsto \lambda x$ and such that for any 
            $\boldsymbol{v},\boldsymbol{u} \in V$ and $\lambda,\mu \in \mathbb{F}$ we have:
            \begin{itemize}
                \item $\lambda(\boldsymbol{u}+\boldsymbol{v}) = \lambda \boldsymbol{u} + \lambda \boldsymbol{v}$
                \item $(\lambda + \mu)\boldsymbol{v} = \lambda \boldsymbol{v} + \mu \boldsymbol{v}$
                \item $(\lambda \mu)\boldsymbol{v} = \lambda(\mu \boldsymbol{v})$
                \item $1\boldsymbol{v} = \boldsymbol{v}$
            \end{itemize}

            Any element $\boldsymbol{v} \in V$ is called a \textbf{vector}, and any element
            $\lambda \in \mathbb{F}$ is called a \textbf{scalar}. We also mark vector elements in 
            boldface.
        \end{definition}
    \end{frame}

    \begin{frame}{Matrix}
        The matrix is a rectangular array of numbers, symbols, or expressions, arranged in rows and 
        columns. For example, the matrix $A$ with $m$ rows and $n$ columns, consisting of elements 
        from the finite field $\mathbb{F}$ is denoted as $A \in \mathbb{F}^{m \times n}$. 

        \begin{definition}
            Let $A,B$ be two matrices over the field $\mathbb{F}$. The following operations are defined:
            \begin{itemize}
                \item \textbf{Matrix addition/subtraction}: $A \pm B = \{a_{i,j} \pm b_{i,j}\}_{i,j=1}^{m \times n}$. The matrices $A$ and $B$ must have the same size $m \times n$.
                \item \textbf{Scalar multiplication}: $\lambda A = \{\lambda a_{i,j}\}_{1\leq i,j \leq n}$ for any $\lambda \in \mathbb{F}$.
                \item \textbf{Matrix multiplication}: $C = AB$ is a matrix $C \in \mathbb{F}^{m \times p}$ with elements $c_{i,j} = \sum_{\ell=1}^{n} a_{i,\ell}b_{\ell,j}$. The number of columns in $A$ must be equal to the number of rows in $B$, that is $A \in \mathbb{F}^{m \times n}$ and $B \in \mathbb{F}^{n \times p}$.
            \end{itemize}
        \end{definition}
    \end{frame}

    \begin{frame}{Matrix Multiplication}
        \begin{example}
            Consider 
            \begin{equation*}
                A = \begin{bmatrix}
                    1 & 1 & 2 \\
                    2 & 2 & 1
                \end{bmatrix} \in \mathbb{R}^{2 \times 3}, \quad B = \begin{bmatrix}
                    2 & 1 \\
                    1 & 3 \\
                    1 & 1
                \end{bmatrix} \in \mathbb{R}^{3 \times 2}
            \end{equation*}
        
            We cannot add $A$ and $B$ since they have different sizes. However, we can multiply them:
            \begin{equation*}
                AB = \begin{bmatrix}
                    5 & 6 \\ 7 & 9
                \end{bmatrix}, \quad BA = \begin{bmatrix}
                    4 & 4 & 5 \\
                    7 & 7 & 5 \\
                    3 & 3 & 3
                \end{bmatrix}
            \end{equation*}
        
            To see why, for example, the upper left element of $AB$ is $5$, we can calculate it as 
            $\sum_{\ell=1}^3 a_{1,\ell}b_{\ell,1} = 1 \times 2 + 1 \times 1 + 2 \times 1 = 5$.
        \end{example}
    \end{frame}

    \begin{frame}{Vector As A Matrix}
        \begin{block}{Note}
            It just so happens that when working with vectors, we usually assume that they are 
            \textbf{column vectors}. This means that the vector $v = (v_1,v_2,\dots,v_n)$ is 
            represented as a matrix:
            \begin{equation*}
                \boldsymbol{v} = \begin{bmatrix} v_1 \\ v_2 \\ \vdots \\ v_n \end{bmatrix}
            \end{equation*} 
            This is a common convention in linear algebra, and we will use it in the following 
            sections.
        \end{block}
    \end{frame}

    \begin{frame}{Matrix Transpose}
        \begin{definition}[Transposition]
            Given a matrix $A \in \mathbb{F}^{m \times n}$, the \textbf{transpose} of $A$ is a 
            matrix $A^{\top} \in \mathbb{F}^{n \times m}$ with elements $A^{\top}_{ij} = A_{ji}$.
        \end{definition}
        
        \begin{example}
            \begin{equation*}
                A = \begin{bmatrix} 1 & 2 \\ 3 & 4 \end{bmatrix}, \quad A^{\top} = \begin{bmatrix} 1 & 3 \\ 2 & 4 \end{bmatrix}
            \end{equation*}
            \begin{equation*}
                B = \begin{bmatrix} 1 & 2 & 3 \\ 4 & 5 & 6 \end{bmatrix}, \quad B^{\top} = \begin{bmatrix} 1 & 4 \\ 2 & 5 \\ 3 & 6 \end{bmatrix}
            \end{equation*}
            \begin{equation*}
                \boldsymbol{v} = \begin{bmatrix} 1 \\ 2 \\ 3 \end{bmatrix}, \quad \boldsymbol{v}^{\top} = [1,2,3]
            \end{equation*}
        \end{example}
    \end{frame}

    \begin{frame}{Inner Product}
        \begin{definition}
            Consider the vector space $\mathbb{V}$ over the finite field $\mathbb{F}_p$. The 
            \textbf{inner product} is a function 
            $\langle \cdot, \cdot \rangle: \mathbb{V} \times \mathbb{V} \to \mathbb{F}_p$ satisfying 
            the following conditions for all $\boldsymbol{u},\boldsymbol{v},\boldsymbol{w} \in \mathbb{V}$:
            \begin{itemize}
                \item $\langle \boldsymbol{u} + \boldsymbol{v}, \boldsymbol{w} \rangle = \langle \boldsymbol{u}, \boldsymbol{w} \rangle + \langle \boldsymbol{v}, \boldsymbol{w} \rangle$.
                \item $\langle \boldsymbol{u}, \boldsymbol{v} + \boldsymbol{w} \rangle = \langle \boldsymbol{u}, \boldsymbol{v} \rangle + \langle \boldsymbol{u}, \boldsymbol{w} \rangle$.
                \item $\langle \boldsymbol{u}, \boldsymbol{v} \rangle = 0$ for all $\boldsymbol{u} \in \mathbb{V}$ iff $\boldsymbol{v} = \boldsymbol{0}$.
                \item $\langle \boldsymbol{u}, \boldsymbol{v} \rangle = 0$ for all $\boldsymbol{v} \in \mathbb{V}$ iff $\boldsymbol{u} = \boldsymbol{0}$.
            \end{itemize}
        \end{definition}   

        Plenty of functions can be built that satisfy the inner product definition, we'll use the one
        that is usually called \textbf{dot product}.
    \end{frame}

    \begin{frame}{Dot Product}
        \begin{definition}
            Consider the vector space $\mathbb{F}^n$ over the finite field $\mathbb{F}$. The 
            \textbf{dot product} on $\mathbb{F}^n$ is a function 
            $\langle \cdot, \cdot \rangle: \mathbb{F}^n \times \mathbb{F}^n \rightarrow \mathbb{F}$, 
            defined for every $\boldsymbol{u}, \boldsymbol{v} \in \mathbb{F}^n$ as follows:
            \begin{equation*}
                \langle \boldsymbol{u}, \boldsymbol{v} \rangle := \boldsymbol{u}^{\top}\boldsymbol{v} = \sum_{i=1}^{n} u_i v_i
            \end{equation*}
        \end{definition}

        
        \begin{block}{Note}                 
            The dot product can also be denoted using the dot notation as:
            \vspace{-8pt}
            \begin{equation*}
                \boldsymbol{u} \cdot \boldsymbol{v}
                \vspace{-8pt}
            \end{equation*}
            That is why it's called the ``dot`` product.
        \end{block}
    \end{frame}

    \begin{frame}{Dot Product}
        \begin{example}
            Let $\boldsymbol{u}, \boldsymbol{v}$ are vectors over the real number $\mathbb{R}$, where
            \begin{equation*}
                \boldsymbol{u} = (1, 2, 3), \quad \boldsymbol{v} = (2, 4, 3)
            \end{equation*}
            Then: 
            \begin{equation*}
                \langle \boldsymbol{u}, \boldsymbol{v}\rangle = \sum_{i=1}^{3}u_iv_i = 2 \cdot 1 + 2 \cdot 4 + 3 \cdot 3 = 2 + 8 + 9 = 19
            \end{equation*}
        \end{example}
    \end{frame}

    \begin{frame}{Hadamard Product}
        \begin{definition}
            Suppose $A,B \in \mathbb{F}^{m \times n}$. The \textbf{Hadamard product} $A \odot B$ 
            gives a matrix $C$ such that $C_{i,j} = A_{i,j}B_{i,j}$. Essentially, we multiply 
            elements elementwise.
        \end{definition}
        
        \begin{example}
            Consider $A = \begin{bmatrix}
                1 & 1 & 2 \\
                3 & 0 & 3
            \end{bmatrix}, B = \begin{bmatrix}
                3 & 2 & 1 \\ 0 & 2 & 1
            \end{bmatrix}$. Then, the Hadamard product:
            \begin{equation*}
                A \odot B = \begin{bmatrix}
                    1 \cdot 3 & 1 \cdot 2 & 2 \cdot 1 \\
                    3 \cdot 0 & 0 \cdot 2 & 3 \cdot 1
                \end{bmatrix} = \begin{bmatrix}
                    3 & 2 & 2 \\
                    0 & 0 & 3
                \end{bmatrix}
            \end{equation*}
        \end{example}
    \end{frame}

    \begin{frame}{Outer Product}
        \begin{definition}
            Given two vectors $\boldsymbol{u} \in \mathbb{F}^n$, $\boldsymbol{v} \in \mathbb{F}^m$ the 
            \textbf{outer product} is a the matrix whose entries are all products of an element in
            the first vector with an element in the second vector:
            \begin{equation*}
                \boldsymbol{u} \otimes \boldsymbol{v} := \boldsymbol{u}\boldsymbol{v}^{\top} = \begin{bmatrix}
                    u_1 v_1 & u_1 v_2 & \cdots & u_1 v_n \\
                    u_2 v_1 & u_2 v_2 & \cdots & u_2 v_n \\
                    \vdots & \vdots & \ddots & \vdots \\
                    u_m v_1 & u_m v_2 & \cdots & u_m v_n
                \end{bmatrix}
            \end{equation*}
        \end{definition}
    \end{frame}

    \begin{frame}{Outer Product}
        \begin{lemma}[Properties of outer product]
            For any scalar $c \in \mathbb{F}$ and $(\boldsymbol{u}, \boldsymbol{v}, \boldsymbol{w}) \in \mathbb{F}^n \times \mathbb{F}^m \times \mathbb{F}^p$:
            \begin{itemize}
                \item Transpose: $(\boldsymbol{u} \otimes \boldsymbol{v}) = (\boldsymbol{v} \otimes \boldsymbol{u})^{\textsf{T}}$
                \item Distributivity: $\boldsymbol{u} \otimes (\boldsymbol{v} + \boldsymbol{w}) = \boldsymbol{u} \otimes \boldsymbol{v} + \boldsymbol{u} \otimes \boldsymbol{w}$
                \item Scalar Multiplication: $c(\boldsymbol{v} \otimes \boldsymbol{u}) = (c\boldsymbol{v}) \otimes \boldsymbol{u} = \boldsymbol{v} \otimes (c\boldsymbol{u})$
                \item Rank: the outer product $\boldsymbol{u} \otimes \boldsymbol{v}$ is a rank-1 matrix if $\boldsymbol{u}$ and $\boldsymbol{v}$ are non-zero
                vectors
            \end{itemize}
        \end{lemma}
    \end{frame}

    \begin{frame}{Outer Product}
        \begin{example}
            Let $\boldsymbol{u}, \boldsymbol{v}$ are vectors over the real number $\mathbb{R}$, where
            \begin{equation*}
                \boldsymbol{u} = (1, 2, 3), \quad \boldsymbol{v} = (2, 4, 3)
            \end{equation*}
            Then: 
            \begin{equation*}
                \boldsymbol{u} \otimes \boldsymbol{v} = \boldsymbol{u}\boldsymbol{v}^{\top} = \begin{bmatrix}
                    1 \cdot 2 & 1 \cdot 4 & 1 \cdot 3 \\
                    2 \cdot 2 & 2 \cdot 4 & 2 \cdot 3 \\
                    3 \cdot 2 & 3 \cdot 4 & 3 \cdot 3
                \end{bmatrix} = \begin{bmatrix}
                    2 & 4 & 3 \\
                    4 & 8 & 6 \\
                    6 & 12 & 9
                \end{bmatrix}
            \end{equation*}

            
            The rows/columns number 2 and 3 in the result matrix can be represented as a linear 
            combination of the first row/column, specifically by multiplying it by 2 and 3, 
            respectively. 
        \end{example}
    \end{frame}

    \section{Rank-1 Constraint System}

    \begin{frame}{Constraint Definition}
        \begin{definition}
            Each \textbf{constraint} in the Rank-1 Constraint System must be in the form:
            \begin{equation*}
                \langle \boldsymbol{a}, \boldsymbol{w}\rangle \times \langle \boldsymbol{b}, \boldsymbol{w}\rangle = \langle \boldsymbol{c}, \boldsymbol{w}\rangle
            \end{equation*}
            Where $\boldsymbol{w}$ is a vector containing all the \textit{input}, \textit{output}, and 
            \textit{intermediate} variables involved in the computation. The vectors $\boldsymbol{a}$, 
            $\boldsymbol{b}$, and $\boldsymbol{c}$ are vectors of coefficients corresponding to these variables, 
            and they define the relationship between the linear combinations of $\boldsymbol{w}$ on the 
            left-hand side and the right-hand side of the equation.
        \end{definition}        
    \end{frame}

    \begin{frame}{Constraint Example}
        \begin{example}
            Consider the most basic circuit with one multiplication gate: $x_1 \times x_2 = r$.
            The witnes vector $\boldsymbol{w} = (r, x_1, x_2)$. So
            \vspace{-5pt}
            \begin{align*}
                w_2 &\times w_3 = w_1 \\
                (0 + w_2 + 0) &\times (0 + 0 + w_3) = w_1 + 0 + 0 \\
                (0w_1 + 1w_2 + 0w_3) &\times (0w_1 + 0w_2 + 1w_3) = 1w_1 + 0w_2 + 0w_3
            \end{align*}
            Therefore the coefficients vectors are:
            \vspace{-5pt}
            \begin{equation*}
                \boldsymbol{a} = (0, 1, 0), \quad \boldsymbol{b} = (0, 0, 1), \quad \boldsymbol{c} = (1, 0, 0). 
                \vspace{-5pt}
            \end{equation*}
            The general form of our constraint is:
            \vspace{-5pt}
            \begin{equation*}
                (a_1w_1 + a_2w_2 + a_3w_3)(b_1w_1 + b_2w_2 + b_3w_3) = c_1w_1 + c_2w_2 + c_3w_3
            \end{equation*}
        \end{example}
    \end{frame}

    \begin{frame}[fragile]{Constraint System Example}
        Now, let us consider a more complex example.
        \begin{lstlisting}[language=Python,numbers=none]
        def r(x1: F, x2: F, x3: F) -> F:
            return x2 * x3 if x1 else x2 + x3
        \end{lstlisting}

        \vspace{-10pt}

        That can be expressed as:
        \begin{equation*}
            r = x_1 \times (x_2 \times x_3) + (1 - x_1) \times (x_2 + x_3)
        \end{equation*}
        
        
        \begin{block}{}
            We need a boolean restriction for $x_1$: that is, $x_1 \times (1 - x_1) = 0$.
        \end{block}

        
        Thus, the next constraints can be built:
        \vspace{-5pt}
        \begin{align*}
            x_1 \times x_1 &= x_1 \quad \text{(binary check)} \tag{1} \\
            x_2 \times x_3 &= \mathsf{mult} \tag{2} \\
            x_1 \times \mathsf{mult} &= \mathsf{selectMult} \tag{3} \\
            (1 - x_1) \times (x_2 + x_3) &= r - \mathsf{selectMult} \tag{4}
        \end{align*}
    \end{frame}

    \begin{frame}[fragile]{Constraint System Example}
        The witness vector: $\boldsymbol{w} = (1, r, x_1, x_2, x_3, \mathsf{mult}, \mathsf{selectMult})$. The coefficients vectors:
        
        \vspace{-20pt}\small

        \begin{align*}
            \boldsymbol{a}_1 &= (0, 0, 1, 0, 0, 0, 0), & \boldsymbol{b}_1 &= (0, 0, 1, 0, 0, 0, 0), & \boldsymbol{c}_1 &= (0, 0, 1, 0, 0, 0, 0) \\
            \boldsymbol{a}_2 &= (0, 0, 0, 1, 0, 0, 0), & \boldsymbol{b}_2 &= (0, 0, 0, 0, 1, 0, 0), & \boldsymbol{c}_2 &= (0, 0, 0, 0, 0, 1, 0) \\
            \boldsymbol{a}_3 &= (0, 0, 1, 0, 0, 0, 0), & \boldsymbol{b}_3 &= (0, 0, 0, 0, 0, 1, 0), & \boldsymbol{c}_3 &= (0, 0, 0, 0, 0, 0, 1) \\
            \boldsymbol{a}_4 &= (1, 0, -1, 0, 0, 0, 0), & \boldsymbol{b}_4 &= (0, 0, 0, 1, 1, 0, 0), & \boldsymbol{c}_4 &= (0, 1, 0, 0, 0, 0, -1)
        \end{align*}\normalsize

        \vspace{-10pt}

        Using the arithmetic in a large $\mathbb{F}_p$, consider the following values:
        
        \vspace{-15pt}
        \begin{equation*}
            x_1 = 1, \quad x_2 = 3, \quad x_3 = 4
            \vspace{-5pt}
        \end{equation*}
    
        Verifying the constraints:
        \begin{enumerate}
            \item \( x_1 \times x_1 = x_1 \quad (1 \times 1 = 1) \)
            \item \( x_2 \times x_3 = \mathsf{mult} \quad (3 \times 4 = 12) \)
            \item \( x_1 \times \mathsf{mult} = \mathsf{selectMult} \quad (1 \times 12 = 12) \)
            \item \( (1 - x_1) \times (x_2 + x_3) = r - \mathsf{selectMult} \quad (0 \times 7 = 12 - 12) \)
        \end{enumerate}
    \end{frame}

    \begin{frame}{R1CS In Matrix Form}
        \begin{theorem} 
            Consider a \textbf{Rank-1 Constraint System} (\textbf{R1CS}) defined over $m$ constraints. Each constraint in such system is
            associated with coefficient vectors $\boldsymbol{a}_i$, $\boldsymbol{b}_i$, and $\boldsymbol{c}_i$, where $i \in \{1, 2, \dots, m\}$ and
            also a witness vector $\boldsymbol{w}$ consisting of $n$ elements.
        
            Then this system can also be represented using the corresponding matrices $A$, $B$, and $C$.
            \begin{align*}
                A = \begin{bmatrix}
                    a_{11} & a_{12} & \dots & a_{1n} \\
                    a_{21} & a_{22} & \dots & a_{2n} \\
                    \vdots & \vdots & \ddots & \vdots \\
                    a_{m1} & a_{m2} & \dots & a_{mn}
                \end{bmatrix}, \; \text{same for $B$ and $C$,}
            \end{align*}
            such that all constraints can be reduced to the single equation:
            \begin{equation*}
                A\boldsymbol{w} \odot B\boldsymbol{w} = C\boldsymbol{w}
            \end{equation*}
        \end{theorem}
    \end{frame}

    \begin{frame}{R1CS In Matrix Form}
        \textbf{Proof.} Matrices defined this way can be expressed as
        \vspace{-5pt}
        {\scriptsize \begin{equation*}
            A = \begin{bmatrix}
                \boldsymbol{a}_1^{\top} \\ \boldsymbol{a}_2^{\top} \\ \vdots \\ \boldsymbol{a}_m^{\top}
            \end{bmatrix}, \quad B = \begin{bmatrix}
                \boldsymbol{b}_1^{\top} \\ \boldsymbol{b}_2^{\top} \\ \vdots \\ \boldsymbol{b}_m^{\top}
            \end{bmatrix}, \quad C = \begin{bmatrix}
                \boldsymbol{c}_1^{\top} \\ \boldsymbol{c}_2^{\top} \\ \vdots \\ \boldsymbol{c}_m^{\top}
            \end{bmatrix}
            \vspace{-5pt}
        \end{equation*}}
        
        Consider an expression $A\boldsymbol{w}$:
        \vspace{-5pt}
        {\scriptsize \begin{equation*}
            A\boldsymbol{w} = \begin{bmatrix}
                \boldsymbol{a}_1^{\top} \\ \boldsymbol{a}_2^{\top} \\ \vdots \\ \boldsymbol{a}_m^{\top}
            \end{bmatrix}\begin{bmatrix}
                w_1 \\ w_2 \\ \vdots \\ w_n
            \end{bmatrix} = \begin{bmatrix}
                \boldsymbol{a}_1^{\top}\boldsymbol{w} \\ \boldsymbol{a}_2^{\top}\boldsymbol{w} \\ \vdots \\ \boldsymbol{a}_m^{\top}\boldsymbol{w}
            \end{bmatrix} = \begin{bmatrix}
                \sum_{i=1}^{n}a_{1i}w_i \\ \sum_{i=1}^{n}a_{2i}w_i \\ \vdots \\ \sum_{i=1}^{n}a_{ni}w_i
            \end{bmatrix} = \begin{bmatrix}
                \langle \boldsymbol{a}_1, \boldsymbol{w}\rangle \\
                \langle \boldsymbol{a}_2, \boldsymbol{w}\rangle \\
                \vdots \\
                \langle \boldsymbol{a}_m, \boldsymbol{w}\rangle 
            \end{bmatrix}
            \vspace{-5pt}
        \end{equation*}}
        
        Therefore, we have:
        \vspace{-5pt}
        {\scriptsize \begin{equation*}
            A\boldsymbol{w} = \begin{bmatrix}
                \langle \boldsymbol{a}_1, \boldsymbol{w}\rangle \\
                \langle \boldsymbol{a}_2, \boldsymbol{w}\rangle \\
                \vdots \\
                \langle \boldsymbol{a}_m, \boldsymbol{w}\rangle 
            \end{bmatrix}, \quad
            B\boldsymbol{w} = \begin{bmatrix}
                \langle \boldsymbol{b}_1, \boldsymbol{w}\rangle \\
                \langle \boldsymbol{b}_2, \boldsymbol{w}\rangle \\
                \vdots \\
                \langle \boldsymbol{b}_m, \boldsymbol{w}\rangle 
            \end{bmatrix}, \quad
            C\boldsymbol{w} = \begin{bmatrix}
                \langle \boldsymbol{c}_1, \boldsymbol{w}\rangle \\
                \langle \boldsymbol{c}_2, \boldsymbol{w}\rangle \\
                \vdots \\
                \langle \boldsymbol{c}_m, \boldsymbol{w}\rangle 
            \end{bmatrix}
            \vspace{-5pt}
        \end{equation*}}
        
        Thus, {\small $A\boldsymbol{w} \odot B\boldsymbol{w} = C\boldsymbol{w}$} is equivalent to the system of $m$ constraints:
        \vspace{-5pt}
        {\small \begin{equation*}
            \langle \boldsymbol{a}_j, \boldsymbol{w}\rangle \times \langle \boldsymbol{b}_j, \boldsymbol{w} \rangle = \langle \boldsymbol{c}_j, \boldsymbol{w} \rangle, \; j \in \{1,\dots,m\}.
        \end{equation*}}
    \end{frame}

    \begin{frame}{R1CS In Matrix Form}
        \begin{example}
            The vectors $\boldsymbol{a}_i$ from the previous examples have the form:
            {\begin{align*}
                \boldsymbol{a}_1 &= (0, 0, 1, 0, 0, 0, 0) \\
                \boldsymbol{a}_2 &= (0, 0, 0, 1, 0, 0, 0) \\
                \boldsymbol{a}_3 &= (0, 0, 1, 0, 0, 0, 0) \\
                \boldsymbol{a}_4 &= (1, 0, -1, 0, 0, 0, 0)
            \end{align*}}
            This corresponds to $n = 7, m = 4$, so the matrix $A$ becomes:
            {\footnotesize \begin{equation*}
                \begin{bmatrix}
                    a_{1,1} & a_{1,2} & a_{1,3} & a_{1,4} & a_{1,5} & a_{1,6} & a_{1,7} \\
                    a_{2,1} & a_{2,2} & a_{2,3} & a_{2,4} & a_{2,5} & a_{2,6} & a_{2,7} \\
                    a_{3,1} & a_{3,2} & a_{3,3} & a_{3,4} & a_{3,5} & a_{3,6} & a_{3,7} \\
                    a_{4,1} & a_{4,2} & a_{4,3} & a_{4,4} & a_{4,5} & a_{4,6} & a_{4,7}
                \end{bmatrix} = \begin{bmatrix}
                    0 & 0 & 1 & 0 & 0 & 0 & 0 \\
                    0 & 0 & 0 & 1 & 0 & 0 & 0 \\
                    0 & 0 & 1 & 0 & 0 & 0 & 0 \\
                    1 & 0 & -1 & 0 & 0 & 0 & 0 
                \end{bmatrix}
            \end{equation*}}
        \end{example}
    \end{frame}

    \begin{frame}{Why Rank-1?}
        \begin{lemma}
            Suppose we have a constraint $\langle \boldsymbol{a}, \boldsymbol{w}\rangle \times \langle \boldsymbol{b}, \boldsymbol{w}\rangle = \langle \boldsymbol{c}, \boldsymbol{w} \rangle$ 
            with coefficient vectors $\boldsymbol{a}$, $\boldsymbol{b}$, $\boldsymbol{c}$ and witness vector 
            $\boldsymbol{w}$ (all from $\mathbb{F}^n$). Then it can be expressed in the form:
            \vspace{-5pt}
            \begin{equation*}
                 \boldsymbol{w}^{\top} A \boldsymbol{w} + \boldsymbol{c}^{\top} \boldsymbol{w} = 0
                 \vspace{-5pt}
            \end{equation*}
            Where $A = \boldsymbol{a} \otimes \boldsymbol{b}$ --- \textbf{rank-1} matrix.
        \end{lemma}
        \vspace{-10pt}
        
        \textbf{Lemma proof.} Consider $\boldsymbol{a}, \boldsymbol{b}, \boldsymbol{c}, \boldsymbol{w} \in \mathbb{F}^n$.
        \vspace{-5pt}
        \begin{equation*}
            \left(\sum_{i=1}^{n} a_i w_i\right) \times \left(\sum_{j=1}^{n} b_j w_j\right) = \sum_{k=1}^{n} c_k w_k
            \vspace{-5pt}
        \end{equation*}
        Combine the products into a double sum on the left side:
        \vspace{-5pt}
        \begin{equation*}
            \sum_{i=1}^{n} \sum_{j=1}^{n} a_i b_j w_i w_j = \boldsymbol{w}^{\top} (\boldsymbol{a} \otimes \boldsymbol{b}) \boldsymbol{w} = \boldsymbol{w}^{\top} A \boldsymbol{w}
            \vspace{-5pt}
        \end{equation*}
        Thus, the constraint can be written as $\boldsymbol{w}^{\top} A \boldsymbol{w} + \boldsymbol{c}^{\top} \boldsymbol{w} = 0$.
    \end{frame}

    \begin{frame}[plain, standout]
        \centering
        \LARGE
        \textbf{Thank you for your attention} \\
        
        \vspace{0.2cm} \Huge \ding{170} \large \\
        
        \vspace{1cm}
  
        \href{https://zkdl-camp.github.io/}{\raisebox{-.1em}{\hspace{.025em}\faIcon{globe}}\hspace{.325em}zkdl-camp.github.io} \\
  
        \href{https://github.com/ZKDL-Camp}{\raisebox{-.1em}{\hspace{.025em}\faIcon{github}}\hspace{.325em}github.com/ZKDL-Camp}
        
        \begin{center}
            \includegraphics[width=0.15\textwidth]{images/logo.png}
        \end{center}
    \end{frame}
\end{document}